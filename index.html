<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Last</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* UI Overlay - HUD Principal */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* Tela de Bloqueio / Menu Inicial */
        #blocker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: url('imagens/tela_inicial.png') center center / cover no-repeat;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            pointer-events: auto;
            z-index: 999;
            color: #e5ddc7;
            text-align: center;
        }
        #blocker::before {
            content: '';
            position: absolute; inset: 0;
            background: rgba(10,16,20,0.82);
            pointer-events: none;
        }
        #title-top-right {
            position: relative;
            margin-top: 6vh;
            margin-bottom: 4vh;
            z-index: 3;
            font-size: clamp(40px, 6vw, 72px);
            font-weight: 700;
            color: #e5ddc7;
            background: none;
            padding: 0;
            border-radius: 0;
            box-shadow: none;
            font-family: 'Cinzel', serif;
            letter-spacing: 2px;
            text-transform: uppercase;
            text-align: center;
            text-shadow: 0 2px 16px #000, 0 1px 0 #222;
        }
        /* INVENTÁRIO */
        #inventory-container {
            display: none; /* Escondido por padrão */
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 400px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 20px;
            z-index: 100; /* Acima do HUD */
            pointer-events: auto; /* Permite clicar */
            color: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 20px;
            height: 300px;
            overflow-y: auto;
        }

        .inv-slot {
            width: 80px;
            height: 80px;
            background: rgba(30,30,30,0.7);
            border: 1px solid #222;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }
        .inv-slot:hover { background: rgba(60,60,60,0.5); border-color: #888; }
        
        /* Ícones simples via CSS para os itens */
        .icon-comida { width: 30px; height: 30px; background: #7a2323; border-radius: 4px; margin-bottom: 5px; box-shadow: 2px 2px 0px rgba(0,0,0,0.6); }
        .icon-agua { width: 30px; height: 30px; background: #1a2a3a; border-radius: 50%; margin-bottom: 5px; box-shadow: 2px 2px 0px rgba(0,0,0,0.6); }
        .icon-espada { width: 30px; height: 30px; margin-bottom: 5px; position: relative; }
        .icon-espada::before {
            content: '';
            display: block;
            position: absolute;
            left: 13px; top: 3px;
            width: 4px; height: 22px;
            background: linear-gradient(180deg, #444 70%, #222 100%);
            border-radius: 2px;
            box-shadow: 1px 1px 2px #222;
        }
        .icon-espada::after {
            content: '';
            display: block;
            position: absolute;
            left: 8px; top: 22px;
            width: 14px; height: 4px;
            background: #6a5520;
            border-radius: 2px;
            box-shadow: 1px 1px 2px #222;
        }
        
        .item-count { font-size: 12px; color: #ccc; }
        .close-btn { position: absolute; top: 10px; right: 15px; cursor: pointer; font-weight: bold; font-size: 20px; color: #a13c3c; }
        /* Menu inicial estilizado (versão: imagem enviada) */
        body { background: linear-gradient(180deg,#0b0f11 0%, #07090a 100%); }
        /* O bloco original duplicado foi removido — usamos definições acima para #blocker e título */
        #blocker::after { content: ''; position: absolute; inset: 0; pointer-events: none; mix-blend-mode: overlay; opacity: 0.06; background-image: repeating-linear-gradient(transparent 0 2px, rgba(0,0,0,0.03) 2px 3px); }
        #instructions { display:flex; flex-direction:column; align-items:center; gap:14px; position:relative; z-index:2; width:100%; }
        /* Ajustes para alinhar os botões em coluna centralizada, como na imagem desejada */
        .menu-panel { background: none; box-shadow: none; border: none; width: 100%; max-width: 420px; padding: 0; display:flex; flex-direction:column; align-items:center; }
        .menu-panel::before, .menu-panel::after { display:none; }
        .menu-row {
            position: fixed;
            top: 32vh; /* baixa a coluna para ficar visível abaixo do título grande */
            right: clamp(40px, 8vw, 120px);
            transform: none;
            display: flex;
            flex-direction: column;
            gap: 22px;
            align-items: center;
            justify-content: center;
            width: min(300px, 38vw);
            z-index: 1200;
            pointer-events: auto;
        }

        /* Mobile fallback: centralizar a coluna em telas estreitas para evitar overflow */
        @media (max-width: 600px) {
            .menu-row {
                position: static;
                transform: none;
                margin: 4vh auto 0 auto;
                width: min(320px, 88vw);
            }
        }
        .menu-btn { padding: 6px 0; font-size: clamp(20px, 4.2vw, 36px); font-family: 'Cinzel', serif; font-weight: 700; background: none; color: #e5ddc7; border: none; width: 320px; max-width: 80vw; text-align: center; letter-spacing: 1px; text-shadow: 0 2px 12px #000, 0 1px 0 #222; cursor: pointer; }
        .menu-btn:hover { color: #fffbe0; text-shadow: 0 4px 24px #000, 0 1px 0 #222; transform: scale(1.02); }
        .menu-subtext { margin-top:14px; font-size:13px; color:rgba(255,255,255,0.85); }
        /* small accent under the menu */
        .menu-accent { height: 2px; width: 120px; background: linear-gradient(90deg, rgba(70,140,255,0.9), rgba(120,80,220,0.9)); border-radius:2px; margin-top:12px; box-shadow: 0 6px 20px rgba(70,140,255,0.06); }
        @keyframes fadeInUp { from { opacity:0; transform: translateY(10px); } to { opacity:1; transform: translateY(0); } }
        .fade-in-up { animation: fadeInUp 560ms ease both; }

        /* Estilo das Barras de Status */
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            width: 300px;
            margin-bottom: 10px;
        }
        .stat-label { color: white; font-weight: bold; margin-bottom: 5px; font-size: 14px; }
        .bar-container { width: 100%; height: 20px; background-color: #333; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.2s; }
        /* Barras de vida dos inimigos (fina, nome em cima) */
        .enemy-health-bar { position: absolute; pointer-events: none; display: none; transform: translate(-50%, -110%); z-index: 30; text-align: center; }
        .enemy-name { color: white; font-size: 12px; font-weight: 300; margin-bottom: 3px; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .enemy-health-outer { width: 80px; height: 8px; background: rgba(0,0,0,0.45); border-radius: 4px; overflow: hidden; border: 1px solid rgba(255,255,255,0.06); }
        .enemy-health-inner { height: 100%; width: 100%; transition: width 0.12s linear; border-radius: 3px; }
        
        #health-bar { background-color: #e74c3c; } 
        #hunger-bar { background-color: #e67e22; } 
        #thirst-bar { background-color: #3498db; } 
        #stamina-bar { background-color: #9b59b6; }

        #interaction-msg {
            position: absolute;
            top: 55%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            display: none;
            background: rgba(0,0,0,0.4);
            padding: 5px 10px;
            border-radius: 4px;
        }
        /* HUD de status — oculto até iniciar o jogo */
        #top-hud { position: absolute; top: 20px; left: 20px; pointer-events: none; display: none; flex-direction: column; align-items: flex-start; z-index: 11; }
        #status-hud { position: absolute; bottom: 20px; left: 20px; pointer-events: none; display: none; flex-direction: column; align-items: flex-start; z-index: 10; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <script src="crafting.js"></script>
</head>
<body>

        <div id="blocker">
            <div id="instructions" class="menu-panel fade-in-up">
                        <div class="menu-row">
                        <button id="resume-btn" class="menu-btn" style="display:none">RETOMAR</button>
                        <button id="start-btn" class="menu-btn">NOVO JOGO</button>
                        <button id="options-btn" class="menu-btn">OPÇÕES</button>
                        <button id="tutorial-btn" class="menu-btn">TUTORIAL</button>
                        <button id="about-btn" class="menu-btn">SOBRE</button>
                    </div>
                </div>
        </div>

    <!-- Barras de vida dos inimigos -->
    <div id="enemies-health-bars" style="position:absolute;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:20;"></div>

    <div id="inventory-container">
        <h2 style="margin:0;">Mochila</h2>
        <div class="close-btn" onclick="closeInventory()">X</div>
        <div style="font-size: 12px; color: #aaa;">Clique no item para usar</div>
        <div id="inventory-grid">
            </div>
    </div>

    <div id="ui-layer">
        <div id="interaction-msg">Pressione 'E' para pegar</div>

        <div id="top-hud">
            <div class="stat-box">
                <div class="stat-label">VIDA</div>
                <div class="bar-container"><div id="health-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
            <div class="stat-box">
                <div class="stat-label">STAMINA</div>
                <div class="bar-container"><div id="stamina-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
        </div>

        <div id="status-hud">
            <div class="stat-box">
                <div class="stat-label">FOME</div>
                <div class="bar-container"><div id="hunger-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
            <div class="stat-box">
                <div class="stat-label">SEDE</div>
                <div class="bar-container"><div id="thirst-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CICLO DIA/NOITE ---
        // Inicia sempre à noite (0.5 = noite) — o ciclo continua normalmente
        let timeOfDay = 0.5; // 0 a 1 (0 = manhã, 0.5 = noite, 1 = manhã)
        function updateDayNight(delta) {
            timeOfDay += delta * 0.01; // 1 ciclo = ~100s
            if (timeOfDay > 1) timeOfDay -= 1;
            // Luz ambiente e cor do céu
            // Usa cos em vez de sin para que timeOfDay=0.5 resulte no valor mínimo (noite)
            const t = Math.abs(Math.cos(timeOfDay * Math.PI));
            scene.background.setHSL(0.6, 0.7, 0.5 * t + 0.1);
            scene.fog.color.setHSL(0.6, 0.7, 0.5 * t + 0.1);
            hemiLight.intensity = 0.2 + 0.6 * t;
            dirLight.intensity = 0.2 + 0.8 * t;
            dirLight.position.y = 100 * t + 10;
        }

        // --- CONFIGURAÇÕES GERAIS ---
        const WORLD_WIDTH = 400;
        const WORLD_DEPTH = 400;
        const TERRAIN_MAX_HEIGHT = 28;
        const WATER_LEVEL = -2.5;
        // Patch tuning
        const PATCH_settings = {
            pedraAltitudeThreshold: 8, // altitude acima da qual consideramos "rochosas"
            pedrinhaChance: 0.5, // chance de gerar pedrinhas em uma posição rochosa (reduzida)
            pedrinhaCountMax: 2, // máximo pedrinhas por ponto (reduzida)
            areiaOpacity: 0.85,
            terraRoughness: 0.95,
            terraPatchScaleMin: 0.8,
            terraPatchScaleMax: 2.2
        };
        const PLAYER_HEIGHT = 2.5; 
        
        // --- ESTADO DO JOGO ---
        let health = 100;
        let hunger = 100;
        let thirst = 100;
        // Stamina / Sprint
        let stamina = 100;
        const MAX_STAMINA = 100;
        const STAMINA_DRAIN = 20; // units per second while sprinting
        const STAMINA_REGEN = 12; // units per second when not sprinting
        const WALK_SPEED = 100.0; // normal walking speed
        const SPRINT_SPEED = 220.0; // previous MOVE_SPEED becomes sprint speed
        const WALK_SPEED_EXHAUSTED = 60.0; // slowed when stamina is 0
        let isSprinting = false;
        // Slow decay (hunger/thirst slower) for limited day/night cycles
        let slowDecayActive = false;
        let slowDecayCyclesLeft = 0; // number of full day/night cycles remaining
        let SLOW_DECAY_FACTOR = 0.5; // multiplier applied to depletion rates while active (0.5 => half rate)
        let previousTimeOfDay = timeOfDay;
        function enableSlowDecay(cycles = 3, factor = 0.5) {
            slowDecayActive = true;
            slowDecayCyclesLeft = cycles;
            SLOW_DECAY_FACTOR = factor;
        }
        let lastTime = performance.now();
        let gameStarted = false;
        
        // Inventário: Array de objetos { type: 'comida', name: 'Maçã', count: N }
        let inventory = [];
        const STACK_LIMIT = 50;
        const STACKABLE_TYPES = new Set(['comida','agua','terra','pedra','areia','graveto','pedrinha']);
        let isInventoryOpen = false;
        let equippedSword = false;
        let swordMesh = null;
        let equippedAxe = false;
        let axeMesh = null;
        // Itens espalhados na cena (colecionáveis)
        const itemsInWorld = [];
        
        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 10, 90);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        // Mantém o canvas oculto até o jogador clicar em "Começar"
        renderer.domElement.style.display = 'none';

        // Luzes
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        scene.add(dirLight);
        // Aplicar aparência inicial imediatamente (começar de noite)
        updateDayNight(0);

        // --- TERRENO ---
        const simplex = new SimplexNoise();
        const geometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH, 180, 180);
        geometry.rotateX(-Math.PI / 2);

        const vertices = geometry.attributes.position.array;
        const colors = [];

        function getNoiseHeight(x, z) {
            // Camadas de ruído: grandes formas, médios detalhes e pequenos detalhes
            let y1 = simplex.noise2D(x * 0.008, z * 0.008) * (TERRAIN_MAX_HEIGHT * 0.6);
            let y2 = simplex.noise2D(x * 0.03, z * 0.03) * (TERRAIN_MAX_HEIGHT * 0.25);
            let y3 = simplex.noise2D(x * 0.12, z * 0.12) * (TERRAIN_MAX_HEIGHT * 0.12);
            let y = y1 + y2 + y3;

            // Cria bacias/lagos usando outra camada de ruído de baixa frequência
            const basin = (simplex.noise2D(x * 0.005 + 1000, z * 0.005 + 1000) - 0.15) * 10; // valores negativos criam depressões
            if (basin < 0) y += basin; // aprofunda o terreno em zonas de bacia

            // Suaviza levemente
            y = (y + simplex.noise2D((x + 1) * 0.008, (z + 1) * 0.008) * (TERRAIN_MAX_HEIGHT * 0.6)) / 2;
            return Math.max(-20, y);
        }

        // Prepara cores levando em conta água/areia/grama/pedra
        function isNearWater(x, z) {
            const steps = [ -3, 0, 3 ];
            for (let sx of steps) for (let sz of steps) {
                const ny = getNoiseHeight(x + sx, z + sz);
                if (ny <= WATER_LEVEL + 0.3) return true;
            }
            return false;
        }

        // Construir uma grade de alturas, aplicar 2 passadas de suavização e então atribuir aos vértices
        const segX = geometry.parameters.widthSegments;
        const segY = geometry.parameters.heightSegments;
        const cols = segX + 1;
        const rows = segY + 1;
        const heights = new Float32Array(cols * rows);

        // Preencher alturas iniciais a partir do ruído
        for (let j = 0; j < rows; j++) {
            for (let i = 0; i < cols; i++) {
                const idx = (j * cols + i) * 3;
                const x = vertices[idx];
                const z = vertices[idx + 2];
                heights[j * cols + i] = getNoiseHeight(x, z);
            }
        }

        // Suavização: 2 passadas médias com vizinhos (preserva formas menores)
        const PASSES = 2;
        for (let pass = 0; pass < PASSES; pass++) {
            const next = new Float32Array(heights.length);
            for (let j = 0; j < rows; j++) {
                for (let i = 0; i < cols; i++) {
                    let sum = 0, count = 0;
                    for (let oy = -1; oy <= 1; oy++) {
                        for (let ox = -1; ox <= 1; ox++) {
                            const ni = i + ox, nj = j + oy;
                            if (ni >= 0 && ni < cols && nj >= 0 && nj < rows) {
                                sum += heights[nj * cols + ni];
                                count++;
                            }
                        }
                    }
                    next[j * cols + i] = sum / count;
                }
            }
            for (let k = 0; k < heights.length; k++) heights[k] = next[k];
        }

        // Função para amostrar a altura suavizada (bilinear) — usada por spawns/objetos
        function sampleHeight(x, z) {
            const fx = (x + WORLD_WIDTH / 2) / WORLD_WIDTH * segX;
            const fz = (z + WORLD_DEPTH / 2) / WORLD_DEPTH * segY;
            const ix = Math.floor(Math.max(0, Math.min(segX - 1, fx)));
            const iz = Math.floor(Math.max(0, Math.min(segY - 1, fz)));
            const tx = fx - ix;
            const tz = fz - iz;
            const i00 = iz * cols + ix;
            const i10 = iz * cols + (ix + 1);
            const i01 = (iz + 1) * cols + ix;
            const i11 = (iz + 1) * cols + (ix + 1);
            const h00 = heights[i00] || 0;
            const h10 = heights[i10] || h00;
            const h01 = heights[i01] || h00;
            const h11 = heights[i11] || h00;
            const h0 = h00 * (1 - tx) + h10 * tx;
            const h1 = h01 * (1 - tx) + h11 * tx;
            return h0 * (1 - tz) + h1 * tz;
        }

        // Aplicar alturas suavizadas aos vértices e gerar cores
        for (let j = 0; j < rows; j++) {
            for (let i = 0; i < cols; i++) {
                const vIdx = (j * cols + i) * 3;
                const h = heights[j * cols + i];
                vertices[vIdx + 1] = h;

                // determine se está próximo da água usando vizinhos
                let nearWater = false;
                for (let oy = -1; oy <= 1 && !nearWater; oy++) {
                    for (let ox = -1; ox <= 1; ox++) {
                        const ni = i + ox, nj = j + oy;
                        if (ni >= 0 && ni < cols && nj >= 0 && nj < rows) {
                            if (heights[nj * cols + ni] <= WATER_LEVEL + 0.3) { nearWater = true; break; }
                        }
                    }
                }

                if (h <= WATER_LEVEL) colors.push(0.12, 0.18, 0.25);
                else if (nearWater && h <= WATER_LEVEL + 2.5) colors.push(0.93, 0.86, 0.66);
                else if (h < 6) colors.push(0.18, 0.72, 0.2);
                else if (h < 14) colors.push(0.54, 0.42, 0.26);
                else colors.push(0.56, 0.56, 0.58);
            }
        }

        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.computeVertexNormals();

        const terrainMat = new THREE.MeshStandardMaterial({ 
            vertexColors: true, flatShading: true, roughness: 0.8 
        });

        
        const terrain = new THREE.Mesh(geometry, terrainMat);
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Água: plano simples cobrindo o mapa
        const waterGeo = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH, 1, 1);
        const waterMat = new THREE.MeshPhongMaterial({ color: 0x2a6fb3, transparent: true, opacity: 0.6, shininess: 40 });
        const water = new THREE.Mesh(waterGeo, waterMat);
        water.rotateX(-Math.PI / 2);
        water.position.y = WATER_LEVEL + 0.05;
        water.receiveShadow = true;
        scene.add(water);

        // Função para achar um ponto de spawn seguro (não submerso)
        function findSafeSpawn(startX = 0, startZ = 30, maxAttempts = 500, searchRadius = 80) {
            if (typeof sampleHeight !== 'function') {
                const fallbackY = getNoiseHeight(startX, startZ);
                return { x: startX, y: Math.max(fallbackY, WATER_LEVEL + 1) + PLAYER_HEIGHT, z: startZ };
            }
            let y = sampleHeight(startX, startZ);
            if (y > WATER_LEVEL + 0.5) return { x: startX, y: y + PLAYER_HEIGHT, z: startZ };

            // Tenta pontos aleatórios ao redor do ponto desejado
            for (let i = 0; i < maxAttempts; i++) {
                const a = Math.random() * Math.PI * 2;
                const r = Math.random() * searchRadius;
                const x = startX + Math.cos(a) * r;
                const z = startZ + Math.sin(a) * r;
                y = sampleHeight(x, z);
                if (y > WATER_LEVEL + 0.5) return { x: x, y: y + PLAYER_HEIGHT, z: z };
            }

            // Varredura simples em grade como último recurso
            const step = 4;
            for (let dx = -searchRadius; dx <= searchRadius; dx += step) {
                for (let dz = -searchRadius; dz <= searchRadius; dz += step) {
                    const x = startX + dx;
                    const z = startZ + dz;
                    y = sampleHeight(x, z);
                    if (y > WATER_LEVEL + 0.5) return { x: x, y: y + PLAYER_HEIGHT, z: z };
                }
            }

            // Fallback: força acima do nível d'água
            const safeY = Math.max(sampleHeight(startX, startZ), WATER_LEVEL + 1);
            return { x: startX, y: safeY + PLAYER_HEIGHT, z: startZ };
        }

        // Posição inicial da câmera (acima do terreno) — procura um ponto seguro em z=30
        const spawnPoint = findSafeSpawn(0, 30);
        camera.position.set(spawnPoint.x, spawnPoint.y + 2, spawnPoint.z);


        // --- BLOCOS (MINERAÇÃO/COLOCAÇÃO) ---
        const blockSize = 2;
        const blocks = [];
        const blockTypes = [
            { type: 'terra', color: 0x8B5A2B },
            { type: 'pedra', color: 0x888888 },
            { type: 'areia', color: 0xEED28A }
        ];
        // Adiciona patches e elementos no mundo (mais discretos)
        for (let i = 0; i < 180; i++) {
            const x = (Math.random() - 0.5) * (WORLD_WIDTH * 0.9);
            const z = (Math.random() - 0.5) * (WORLD_DEPTH * 0.9);
            const terrainY = (typeof sampleHeight === 'function') ? sampleHeight(x, z) : getNoiseHeight(x, z);

            // Regiões rochosas: spawn de pedrinhas (clusters)
            if (terrainY > PATCH_settings.pedraAltitudeThreshold) {
                if (Math.random() < PATCH_settings.pedrinhaChance) {
                    const count = 1 + Math.floor(Math.random() * PATCH_settings.pedrinhaCountMax);
                    for (let s = 0; s < count; s++) {
                        const ox = (Math.random() - 0.5) * 3.2;
                        const oz = (Math.random() - 0.5) * 3.2;
                        spawnItem('pedrinha', x + ox, z + oz, terrainY + (Math.random() * 0.4 - 0.2));
                    }
                }
                continue;
            }

            // Areia: placas discretas no chão (submersas) — mais sutis
            if (terrainY <= WATER_LEVEL + 1.2) {
                const t = blockTypes.find(b => b.type === 'areia');
                const planeSize = blockSize * (0.9 + Math.random() * 1.2);
                const mesh = new THREE.Mesh(
                    new THREE.PlaneGeometry(planeSize, planeSize),
                    new THREE.MeshStandardMaterial({ color: t.color, transparent: true, opacity: PATCH_settings.areiaOpacity, side: THREE.DoubleSide, roughness: 0.9 })
                );
                mesh.rotateX(-Math.PI / 2);
                mesh.position.set(x + (Math.random() - 0.5) * 0.6, terrainY + 0.02, z + (Math.random() - 0.5) * 0.6);
                mesh.receiveShadow = false;
                mesh.userData = { type: t.type };
                scene.add(mesh);
                continue;
            }

            // Terra: patches discretos no chão (planos rotacionados, aspecto natural)
            const t = blockTypes.find(b => b.type === 'terra');
            const scale = PATCH_settings.terraPatchScaleMin + Math.random() * (PATCH_settings.terraPatchScaleMax - PATCH_settings.terraPatchScaleMin);
            const w = blockSize * scale;
            const h = blockSize * (0.8 + Math.random() * 1.2);
            const mesh = new THREE.Mesh(
                new THREE.PlaneGeometry(w, h),
                new THREE.MeshStandardMaterial({ color: t.color, roughness: PATCH_settings.terraRoughness, side: THREE.DoubleSide })
            );
            mesh.rotateX(-Math.PI / 2);
            mesh.position.set(x + (Math.random() - 0.5) * 0.6, terrainY + 0.02 + (Math.random() * 0.02), z + (Math.random() - 0.5) * 0.6);
            mesh.rotation.z = Math.random() * Math.PI * 2;
            mesh.receiveShadow = true;
            mesh.userData = { type: t.type };
            scene.add(mesh);
            blocks.push(mesh);
        }

        // --- OBJETOS ---
        let isCraftingOpen = false;

        // --- INIMIGOS ---
        const enemies = [];
        // Árvores no mundo (referências para interações)
        const trees = [];
        function spawnEnemy(x, z, y, kind) {
            // Monstros: 'vampiro' | 'Lobisomen' | 'zombie'
            const kinds = ['vampiro', 'Lobisomen', 'zombie'];
            const k = kind || kinds[Math.floor(Math.random() * kinds.length)];

            let enemyGeo, enemyMat, color = 0x990000, speed = 3.5, damage = 12, maxHealth = 100, scaleY = 2;
            if (k === 'vampiro') {
                color = 0x8e44ad; // purple-ish
                speed = 4.5; // rápido
                damage = 18; // razoável
                maxHealth = 100;
                enemyGeo = new THREE.BoxGeometry(0.9, 1.8, 0.9);
            } else if (k === 'Lobisomen') {
                color = 0x333333; // dark
                speed = 6.0; // muito rápido
                damage = 8; // fraco
                maxHealth = 220;
                enemyGeo = new THREE.BoxGeometry(1.0, 1.9, 1.0);
            } else { // zombie
                color = 0x2e8b57; // green-ish
                speed = 1.0; // muito lento
                damage = 36; // muito forte
                maxHealth = 80;
                enemyGeo = new THREE.BoxGeometry(1.1, 2.4, 1.1);
            }

            enemyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
            const enemy = new THREE.Mesh(enemyGeo, enemyMat);
            enemy.position.set(x, y + (scaleY/2 || 1), z);
            enemy.castShadow = true;
            // Vida máxima e atual + speed e tipo
            enemy.userData = { kind: k, alive: true, damage: damage, maxHealth: maxHealth, health: maxHealth, speed: speed, healthBarId: null };
            scene.add(enemy);
            enemies.push(enemy);
            // Criar barra de vida HTML mais sofisticada (nome + barra fina)
            const bar = document.createElement('div');
            bar.className = 'enemy-health-bar';
            const nameDiv = document.createElement('div');
            nameDiv.className = 'enemy-name';
            nameDiv.innerText = (k === 'vampiro') ? 'Vampiro' : (k === 'Lobisomen') ? 'Lobisomem' : 'Zumbi';
            bar.appendChild(nameDiv);
            const outer = document.createElement('div');
            outer.className = 'enemy-health-outer';
            const inner = document.createElement('div');
            inner.className = 'enemy-health-inner';
            // color inner by type for quick feedback
            if (k === 'vampiro') inner.style.background = '#b368d6';
            else if (k === 'Lobisomen') inner.style.background = '#999999';
            else inner.style.background = '#66aa66';
            inner.style.width = '100%';
            outer.appendChild(inner);
            bar.appendChild(outer);
            document.getElementById('enemies-health-bars').appendChild(bar);
            enemy.userData.healthBarId = bar;
        }

        // Spawnar alguns inimigos
        for (let i = 0; i < 12; i++) {
            const x = (Math.random() - 0.5) * (WORLD_WIDTH * 0.8);
            const z = (Math.random() - 0.5) * (WORLD_DEPTH * 0.8);
            const y = getNoiseHeight(x, z);
            if (y > WATER_LEVEL + 1) spawnEnemy(x, z, y);
        }

        function spawnTree(x, z, y) {
            const treeGroup = new THREE.Group();
            
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 2.5, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, flatShading: true });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.25;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leavesGeo = new THREE.ConeGeometry(2.5, 5, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22, flatShading: true });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 4.0; 
            leaves.castShadow = true;
            treeGroup.add(leaves);

            treeGroup.position.set(x, y, z);
            // marca dados para interação (contador de socos e gravetos)
            treeGroup.userData = { type: 'tree', punches: 0, twigsDropped: 0, exhausted: false };
            scene.add(treeGroup);
            trees.push(treeGroup);
        }

        function spawnItem(type, x, z, y) {
            if (type === 'comida') { 
                const geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                const material = new THREE.MeshStandardMaterial({ color: 0xFF4444, roughness: 0.2 });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(x, y + 0.8, z);
                mesh.castShadow = true;
                mesh.userData = { type: type, active: true, baseY: mesh.position.y, phase: Math.random() * Math.PI * 2 };
                scene.add(mesh);
                itemsInWorld.push(mesh);
            } else if (type === 'agua') {
                const geometry = new THREE.SphereGeometry(0.4, 8, 8);
                const material = new THREE.MeshStandardMaterial({ color: 0x4444FF, roughness: 0.2 });
                const mesh = new THREE.Mesh(geometry, material);
                // Garantir que água seja criada submersa (dentro do mar)
                let placeY = y;
                // Se o ponto fornecido estiver acima do nível da água, força posicionamento abaixo da superfície
                if (placeY > WATER_LEVEL - 0.2) {
                    placeY = WATER_LEVEL - (0.5 + Math.random() * 0.8);
                }
                mesh.position.set(x, placeY + 0.4, z);
                mesh.castShadow = true;
                mesh.userData = { type: type, active: true, baseY: mesh.position.y, phase: Math.random() * Math.PI * 2 };
                scene.add(mesh);
                itemsInWorld.push(mesh);
            } else if (type === 'espada') {
                
                return;
            } else if (type === 'graveto') {
                const geom = new THREE.BoxGeometry(0.2, 0.06, 0.6);
                const mat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B, roughness: 0.8 });
                const mesh = new THREE.Mesh(geom, mat);
                mesh.position.set(x, y + 0.4, z);
                mesh.rotation.y = Math.random() * Math.PI * 2;
                mesh.castShadow = true;
                mesh.userData = { type: type, active: true, baseY: mesh.position.y, phase: Math.random() * Math.PI * 2 };
                scene.add(mesh);
                itemsInWorld.push(mesh);
            } else if (type === 'pedrinha') {
                // Pequena pedra esférica no chão — colecionável
                const radius = 0.14 + Math.random() * 0.18; // pequeno raio
                const geom = new THREE.SphereGeometry(radius, 12, 10);
                const mat = new THREE.MeshStandardMaterial({ color: 0x909090, roughness: 0.8, metalness: 0.03 });
                const mesh = new THREE.Mesh(geom, mat);
                // Posiciona encostada no chão (base da esfera em y)
                mesh.position.set(x, y + radius + 0.01, z);
                mesh.rotation.y = Math.random() * Math.PI * 2;
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { type: type, active: true, baseY: mesh.position.y, phase: Math.random() * Math.PI * 2 };
                scene.add(mesh);
                itemsInWorld.push(mesh);
            }
        }

        // Popular
        for (let i = 0; i < 240; i++) {
            const x = (Math.random() - 0.5) * (WORLD_WIDTH * 0.9);
            const z = (Math.random() - 0.5) * (WORLD_DEPTH * 0.9);
            const y = (typeof sampleHeight === 'function') ? sampleHeight(x, z) : getNoiseHeight(x, z);

            if (y > WATER_LEVEL + 0.5) {
                const r = Math.random();
                if (r < 0.55) spawnTree(x, z, y);
                else if (r < 0.75) spawnItem('comida', x, z, y);
                else if (r < 0.93) spawnItem('agua', x, z, y);
                else spawnItem('pedrinha', x, z, y);
            }
            else {
                // Áreas submersas / beira d'água: prioriza spawns de água submersa
                // Se estiver claramente abaixo ou próximo à superfície, spawnar 'agua' com boa chance
                if (y <= WATER_LEVEL + 0.5) {
                    const r2 = Math.random();
                    if (r2 < 0.6) spawnItem('agua', x, z, y);
                    else if (r2 < 0.75) spawnItem('comida', x, z, y);
                    else if (r2 < 0.9) spawnItem('pedrinha', x, z, y);
                } else {
                    // beira d'água / lama rasa: pequenas chances de itens de praia
                    if (Math.random() < 0.05) spawnItem('comida', x, z, y);
                    else if (Math.random() < 0.02) spawnItem('pedrinha', x, z, y);
                }
            }
        }

        // --- CONTROLES E SISTEMA DE JOGO ---
        // Use the renderer canvas as the pointer-lock element so lock/unlock requests
        // originate from the visible game canvas and work reliably when resuming.
        const controls = new PointerLockControls(camera, renderer.domElement);
        // Posiciona o objeto de controle (jogador) acima do terreno no início
        // Posiciona o objeto de controle (jogador) acima do terreno no início usando ponto seguro
        if (typeof spawnPoint !== 'undefined') {
            controls.getObject().position.set(spawnPoint.x, spawnPoint.y, spawnPoint.z);
        } else {
            controls.getObject().position.set(0, (typeof sampleHeight === 'function') ? sampleHeight(0, 0) + PLAYER_HEIGHT : getNoiseHeight(0,0) + PLAYER_HEIGHT, 30);
        }
        
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const startBtn = document.getElementById('start-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const tutorialBtn = document.getElementById('tutorial-btn');
        const invContainer = document.getElementById('inventory-container');

        // Estado das teclas
        const keyState = {};

        // Botões do menu (adiciona listeners somente se existirem)
        if (startBtn) startBtn.addEventListener('click', function () { startGame(); });
        if (resumeBtn) resumeBtn.addEventListener('click', function (e) {
            e.preventDefault();
            try {
                if (document.body) { document.body.tabIndex = -1; document.body.focus(); }
                if (renderer && renderer.domElement) {
                    renderer.domElement.style.display = '';
                    renderer.domElement.tabIndex = -1;
                    renderer.domElement.focus();
                    // Request pointer lock directly on the canvas; browsers require this to be from a user gesture
                    if (typeof renderer.domElement.requestPointerLock === 'function') {
                        renderer.domElement.requestPointerLock();
                    }
                }
            } catch (err) {}
            // As a fallback, also call controls.lock() which will attempt requestPointerLock on the configured element
            try { controls.lock(); } catch (err) {}
        });

        // Listen to raw pointer lock changes to ensure UI and focus update when lock state changes
        document.addEventListener('pointerlockchange', () => {
            const locked = document.pointerLockElement === renderer.domElement;
            if (locked) {
                if (blocker) blocker.style.display = 'none';
                if (invContainer) invContainer.style.display = 'none';
                isInventoryOpen = false;
                try { renderer.domElement.focus(); } catch (err) {}
            } else {
                // If pointer unlocked during gameplay, only show blocker/menu when
                // neither the inventory nor the crafting UI are open. This prevents
                // opening crafting (which unlocks the pointer) from immediately
                // showing the main menu and 'travar' a interação.
                if (!isInventoryOpen && !isCraftingOpen) {
                    if (gameStarted) {
                        if (blocker) blocker.style.display = 'flex';
                    }
                } else {
                    // If inventory or crafting is open, ensure the correct panels are visible
                    if (isInventoryOpen) {
                        if (invContainer) invContainer.style.display = 'block';
                        if (blocker) blocker.style.display = 'none';
                    }
                    if (isCraftingOpen) {
                        if (blocker) blocker.style.display = 'none';
                        if (invContainer) invContainer.style.display = 'none';
                    }
                }
            }
        });
        if (tutorialBtn) tutorialBtn.addEventListener('click', function () { openTutorial(); });
        // Novos botões: Sobre e Opções
        const aboutBtn = document.getElementById('about-btn');
        const optionsBtn = document.getElementById('options-btn');
        if (aboutBtn) aboutBtn.addEventListener('click', function () { openAbout(); });
        if (optionsBtn) optionsBtn.addEventListener('click', function () { openOptions(); });

        // Eventos do PointerLock
        controls.addEventListener('lock', function () {
            blocker.style.display = 'none';
            invContainer.style.display = 'none';
            isInventoryOpen = false;
        });

        controls.addEventListener('unlock', function () {
            // Se o inventário estiver aberto, NÃO mostra o menu de bloqueio
            if (isInventoryOpen) {
                blocker.style.display = 'none';
                invContainer.style.display = 'block';
                renderInventory();
            } else if (isCraftingOpen) {
                // Ao abrir crafting queremos apenas mostrar o cursor/modal sem exibir o blocker
                blocker.style.display = 'none';
                invContainer.style.display = 'none';
            } else {
                blocker.style.display = 'flex';
                instructions.style.display = '';
                invContainer.style.display = 'none';
                // Se o jogo já tinha começado, mostramos o botão 'Retomar' em vez de 'Começar'
                if (gameStarted) {
                    if (startBtn) startBtn.style.display = 'none';
                    if (resumeBtn) resumeBtn.style.display = '';
                    if (aboutBtn) aboutBtn.style.display = 'none';
                } else {
                    if (startBtn) startBtn.style.display = '';
                    if (resumeBtn) resumeBtn.style.display = 'none';
                    if (aboutBtn) aboutBtn.style.display = '';
                }
            }
        });

        // Função para iniciar o jogo (mostra o canvas e inicia o loop)
        function startGame() {
            if (gameStarted) return;
            console.log('startGame: inicializando...');
            renderer.domElement.style.display = '';
            try {
                // Inicia loop de animação e travamento de ponteiro
                animate();
            } catch (err) {
                console.error('Erro ao iniciar animate():', err);
                showStartupError('Erro ao iniciar o loop de jogo. Veja o console.');
                return;
            }
            try {
                controls.lock();
            } catch (err) {
                console.warn('Não foi possível travar o pointer diretamente:', err);
            }
            // Mostrar HUD de status quando o jogo iniciar
            const hud = document.getElementById('status-hud');
            const topHud = document.getElementById('top-hud');
            if (hud) hud.style.display = 'flex';
            if (topHud) topHud.style.display = 'flex';
            // Ativa redução de taxa de fome/sede por até 3 ciclos (dias+noites)
            enableSlowDecay(3, 0.5);
            gameStarted = true;
            console.log('startGame: pronto');
        }

        function showStartupError(msg) {
            let e = document.getElementById('startup-error');
            if (!e) {
                e = document.createElement('div');
                e.id = 'startup-error';
                e.style = 'position:fixed;left:10px;top:10px;z-index:9999;background:#800;color:#fff;padding:10px;border-radius:6px;font-family:Segoe UI, Tahoma, sans-serif;';
                document.body.appendChild(e);
            }
            e.innerText = msg;
        }

        // Modal de tutorial
        function openTutorial() {
            if (document.getElementById('tutorial-modal')) return;
            const div = document.createElement('div');
            div.id = 'tutorial-modal';
            div.style = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:24px;z-index:1000;border-radius:10px;max-width:600px;';
            div.innerHTML = `
                <h2 style="margin-top:0;">Tutorial</h2>
                <p>(W, A, S, D) Mover | (ESPAÇO) Pular</p>
                <p>(E) Pegar Items | (I) Abrir Inventário</p>
                <p>(C) Abrir Crafting | (ESC) Menu / Sair do Jogo</p>
                <div style="text-align:right;margin-top:12px;"><button id="close-tutorial" style="padding:8px 12px;">Fechar</button></div>
            `;
            document.body.appendChild(div);
            document.getElementById('close-tutorial').addEventListener('click', () => { div.remove(); });
        }

        // Modal 'Sobre'
        function openAbout() {
            if (document.getElementById('about-modal')) return;
            const div = document.createElement('div');
            div.id = 'about-modal';
            div.style = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:24px;z-index:1000;border-radius:10px;max-width:500px;';
            div.innerHTML = `
                <h2 style="margin-top:0;">Sobre</h2>
                <p>One Last Pré Alpha Versão: -5.1</p>
                <p>Criador: Kzinn</p>
                <div style="text-align:right;margin-top:12px;"><button id="close-about" style="padding:8px 12px;">Fechar</button></div>
            `;
            document.body.appendChild(div);
            document.getElementById('close-about').addEventListener('click', () => { div.remove(); });
        }

        // Modal 'Opções' (apenas mensagem por enquanto)
        function openOptions() {
            if (document.getElementById('options-modal')) return;
            const div = document.createElement('div');
            div.id = 'options-modal';
            div.style = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:24px;z-index:1000;border-radius:10px;max-width:500px;';
            div.innerHTML = `
                <h2 style="margin-top:0;">Opções</h2>
                <p>ainda não é possivel mexer aqui!</p>
                <div style="text-align:right;margin-top:12px;"><button id="close-options" style="padding:8px 12px;">Fechar</button></div>
            `;
            document.body.appendChild(div);
            document.getElementById('close-options').addEventListener('click', () => { div.remove(); });
        }

        // Controles de Teclado
        document.addEventListener('keydown', (e) => {
            keyState[e.code] = true;

            if (e.code === 'KeyE') checkInteraction();
            if (e.code === 'KeyI' || e.code === 'Tab') {
                e.preventDefault(); // Evita tab mudar foco do navegador
                toggleInventory();
            }
            // Se o jogador apertar ESC enquanto o jogo está iniciado e o pointer estiver desbloqueado, tente relockar (user gesture)
            if (e.code === 'Escape') {
                if (!controls.isLocked && gameStarted) {
                    // Tentar travar novamente; alguns navegadores podem exigir clique, mas tentamos
                    try { controls.lock(); } catch (err) {}
                }
            }
        });
        document.addEventListener('keyup', (e) => keyState[e.code] = false);

        // --- REGISTRAR HANDLER DE SOCO (apenas após `controls` existir) ---
        // Soco sem arma: quando não estiver com espada equipada, dano 8 e interage com árvores
        window.addEventListener('mousedown', (e) => {
            if (equippedSword || isInventoryOpen || !controls || !controls.isLocked) return;
            if (e.button !== 0) return; // somente botão esquerdo
            const PUNCH_DAMAGE = 8;
            const playerPos = controls.getObject().position.clone();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);

            let hitAnything = false;

            // Ataca inimigos próximos
            enemies.forEach(enemy => {
                if (!enemy.userData.alive || enemy.userData.health <= 0) return;
                const toEnemy = enemy.position.clone().sub(playerPos);
                const dist = toEnemy.length();
                toEnemy.y = 0; forward.y = 0;
                if (toEnemy.lengthSq() === 0) return;
                const angle = forward.angleTo(toEnemy.normalize());
                if (dist < 2.4 && angle < Math.PI / 3) {
                    enemy.userData.health -= PUNCH_DAMAGE;
                    if (enemy.userData.health <= 0) {
                        enemy.userData.alive = false;
                        enemy.visible = false;
                    }
                    hitAnything = true;
                }
            });

            // Ataca árvores próximas (não quebra, apenas droppa gravetos conforme contadores)
            for (let i = trees.length - 1; i >= 0; i--) {
                const tree = trees[i];
                if (!tree || !tree.userData) continue;
                const toTree = tree.position.clone().sub(playerPos);
                const dist = toTree.length();
                toTree.y = 0; forward.y = 0;
                if (dist < 3.0) {
                    const angle = forward.angleTo(toTree.normalize());
                    if (angle < Math.PI / 2) {
                        if (tree.userData.exhausted) break;
                        hitAnything = true;
                        tree.position.y += 0.03;
                        setTimeout(() => { if (tree) tree.position.y -= 0.03; }, 120);
                        // Se estiver com machado, derruba mais gravetos instantaneamente
                        if (equippedAxe) {
                            tree.userData.twigsDropped = tree.userData.twigsDropped || 0;
                            const tx = tree.position.x, tz = tree.position.z, ty = tree.position.y;
                            // Drop 2 gravetos
                            for (let g = 0; g < 2; g++) {
                                const ox = (Math.random() - 0.5) * 1.2;
                                const oz = (Math.random() - 0.5) * 1.2;
                                spawnItem('graveto', tx + ox, tz + oz, ty);
                                tree.userData.twigsDropped++;
                            }
                            if (tree.userData.twigsDropped >= 3) tree.userData.exhausted = true;
                        } else {
                            tree.userData.punches = (tree.userData.punches || 0) + 1;
                            if (tree.userData.punches >= 2) {
                                tree.userData.punches = 0;
                                tree.userData.twigsDropped = tree.userData.twigsDropped || 0;
                                if (tree.userData.twigsDropped < 3) {
                                    const tx = tree.position.x, tz = tree.position.z, ty = tree.position.y;
                                    const ox = (Math.random() - 0.5) * 1.2;
                                    const oz = (Math.random() - 0.5) * 1.2;
                                    spawnItem('graveto', tx + ox, tz + oz, ty);
                                    tree.userData.twigsDropped++;
                                    if (tree.userData.twigsDropped >= 3) tree.userData.exhausted = true;
                                } else {
                                    tree.userData.exhausted = true;
                                }
                            }
                        }
                        break;
                    }
                }
            }

            if (hitAnything) {
                const orig = camera.rotation.x;
                camera.rotation.x -= 0.08;
                setTimeout(() => { camera.rotation.x = orig; }, 100);
            }
        });

        // --- LÓGICA DE INVENTÁRIO ---

        function toggleInventory() {
            if (isInventoryOpen) {
                // Fecha
                isInventoryOpen = false;
                invContainer.style.display = 'none';
                controls.lock(); // Volta a travar o mouse para o jogo
            } else {
                // Abre
                isInventoryOpen = true;
                controls.unlock(); // Solta o mouse para clicar na UI
                // O evento 'unlock' cuidará de mostrar a div
            }
        }
        
        // Torna a função global para o botão 'X' do HTML funcionar
        window.closeInventory = function() {
            if(isInventoryOpen) toggleInventory();
        };

        function addToInventory(type) {
            const nameMap = { comida: 'Maçã', agua: 'Água', espada: 'Espada', terra: 'Terra', pedra: 'Pedra', areia: 'Areia', graveto: 'Graveto', pedrinha: 'Pedrinha' };
            nameMap['machado'] = 'Machado';
            const name = nameMap[type] || type;
            const isStackable = STACKABLE_TYPES.has(type);

            if (isStackable) {
                // Tenta empilhar em pilhas existentes até o limite
                let remaining = 1;
                for (let i = 0; i < inventory.length && remaining > 0; i++) {
                    const it = inventory[i];
                    if (it.type === type && (it.count || 0) < STACK_LIMIT) {
                        const space = STACK_LIMIT - (it.count || 0);
                        const add = Math.min(space, remaining);
                        it.count = (it.count || 0) + add;
                        remaining -= add;
                    }
                }
                // Se ainda restar, cria nova pilha
                if (remaining > 0) {
                    inventory.push({ type: type, name: name, id: Date.now() + Math.random(), count: remaining });
                }
            } else {
                inventory.push({ type: type, name: name, id: Date.now() + Math.random(), count: 1 });
            }
            // Feedback visual simples
            const msg = document.getElementById('interaction-msg');
            let msgName = name;
            msg.innerText = `Pegou: ${msgName}`;
            msg.style.display = 'block';
            setTimeout(() => { 
                if(!isInventoryOpen) msg.style.display = 'none'; 
                msg.innerText = "Pressione 'E' para pegar";
            }, 2000);
        }

        function renderInventory() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';
            if (inventory.length === 0) {
                grid.innerHTML = '<div style="grid-column: span 5; text-align:center; padding: 20px;">Mochila vazia</div>';
                return;
            }
            inventory.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                let iconClass = '';
                if (item.type === 'comida') iconClass = 'icon-comida';
                else if (item.type === 'agua') iconClass = 'icon-agua';
                else if (item.type === 'espada') iconClass = 'icon-espada';
                else if (item.type === 'terra') iconClass = '';
                else if (item.type === 'pedra') iconClass = '';
                else if (item.type === 'pedrinha') iconClass = '';
                else if (item.type === 'areia') iconClass = '';
                // Se for espada, tenta gerar um ícone via canvas/textura
                if (item.type === 'espada') {
                    const icon = createSwordIconCanvas(80);
                    const dataUrl = icon.toDataURL();
                    slot.innerHTML = `
                        <div style="width:60px;height:60px;border-radius:8px;margin-bottom:5px;display:flex;align-items:center;justify-content:center;">
                            <img src="${dataUrl}" style="width:56px;height:56px;display:block;" />
                        </div>
                        <span class="item-count">${item.name}</span>
                    `;
                } else {
                    const bgColor = item.type==='terra' ? '#8B5A2B' : item.type==='pedra' || item.type==='pedrinha' ? '#888' : '#EED28A';
                    slot.innerHTML = `
                        <div class="${iconClass}" style="width:30px;height:30px;background:${bgColor};border-radius:4px;margin-bottom:5px;"></div>
                        <span class="item-count">${item.name}</span>
                    `;
                }
                if (item.type === 'machado') {
                    const icon = createAxeIconCanvas(80);
                    const dataUrl = icon.toDataURL();
                    slot.innerHTML = `
                        <div style="width:60px;height:60px;border-radius:8px;margin-bottom:5px;display:flex;align-items:center;justify-content:center;">
                            <img src="${dataUrl}" style="width:56px;height:56px;display:block;" />
                        </div>
                        <span class="item-count">${item.name}</span>
                    `;
                }
                // Badge de contagem (empilhamento)
                if ((item.count || 0) > 1) {
                    const badge = document.createElement('div');
                    badge.style = 'position:absolute;top:6px;right:8px;background:rgba(0,0,0,0.65);color:#fff;padding:2px 6px;border-radius:10px;font-size:12px;pointer-events:none;';
                    badge.innerText = 'x' + item.count;
                    slot.appendChild(badge);
                }
                slot.onclick = () => useItem(index);
                grid.appendChild(slot);
            });
        }

        function useItem(index) {
            const item = inventory[index];
            if (item.type === 'comida') {
                hunger = Math.min(100, hunger + 30);
                health = Math.min(100, health + 5);
                if (item.count && item.count > 1) item.count--; else inventory.splice(index, 1);
            } else if (item.type === 'agua') {
                thirst = Math.min(100, thirst + 30);
                health = Math.min(100, health + 2);
                if (item.count && item.count > 1) item.count--; else inventory.splice(index, 1);
            } else if (item.type === 'espada') {
                if (!equippedSword) {
                    equippedSword = true;
                    // Desequipa machado se estiver equipado
                    if (equippedAxe) { equippedAxe = false; hideAxeInHand(); }
                    showSwordInHand();
                    alert('Espada equipada! Clique para atacar.');
                } else {
                    equippedSword = false;
                    hideSwordInHand();
                    alert('Espada guardada!');
                }
            } else if (item.type === 'machado') {
                if (!equippedAxe) {
                    equippedAxe = true;
                    // Desequipa espada se estiver equipada
                    if (equippedSword) { equippedSword = false; hideSwordInHand(); }
                    showAxeInHand();
                    alert('Machado equipado! Use para derrubar árvores.');
                } else {
                    equippedAxe = false;
                    hideAxeInHand();
                    alert('Machado guardado!');
                }
            } else if (item.type === 'terra' || item.type === 'pedra' || item.type === 'areia') {
                // Colocar bloco no mundo
                placeBlock(item.type);
                if (item.count && item.count > 1) item.count--; else inventory.splice(index, 1);
            }
            updateHUD();
            renderInventory();
        }
                // Colocação de bloco
                function placeBlock(type) {
                    // Posição à frente do jogador
                    const pos = controls.getObject().position.clone();
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    dir.multiplyScalar(4);
                    const placePos = pos.add(dir);
                    // Alinha à grade
                    const bx = Math.round(placePos.x / blockSize) * blockSize;
                    const by = Math.round((placePos.y-PLAYER_HEIGHT) / blockSize) * blockSize + blockSize/2 + PLAYER_HEIGHT;
                    const bz = Math.round(placePos.z / blockSize) * blockSize;
                    const t = blockTypes.find(b=>b.type===type);
                    if (!t) return;
                    const mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                        new THREE.MeshStandardMaterial({ color: t.color })
                    );
                    mesh.position.set(bx, by, bz);
                    mesh.castShadow = true;
                    mesh.userData = { type: t.type };
                    scene.add(mesh);
                    blocks.push(mesh);
                }
                // Mineração de bloco
                window.addEventListener('mousedown', (e) => {
                    if (isInventoryOpen || !controls.isLocked) return;
                    // Raycast para blocos
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                    const intersects = raycaster.intersectObjects(blocks);
                    if (intersects.length > 0) {
                        const block = intersects[0].object;
                        addToInventory(block.userData.type);
                        scene.remove(block);
                        const idx = blocks.indexOf(block);
                        if (idx >= 0) blocks.splice(idx,1);
                        return;
                    }
                });
                function openCrafting() {
                    isCraftingOpen = true;
                    try { if (controls && controls.isLocked) controls.unlock(); } catch(e) {}
                    let html = '<h2>Crafting</h2>';
                    craftingRecipes.forEach((r, i) => {
                        html += `<div style="margin:8px 0;"><b>${r.name}</b> <button onclick="craftItem(${i})">Craft</button><br><small>Requer: `;
                        html += Object.entries(r.requires).map(([k,v])=>`${v} ${k}`).join(', ');
                        html += '</small></div>';
                    });
                    const div = document.createElement('div');
                    div.id = 'crafting-modal';
                    div.style = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#222;color:#fff;padding:30px;z-index:200;border-radius:10px;box-shadow:0 0 20px #000b;';
                    div.innerHTML = html + '<br><button onclick="closeCrafting()">Fechar</button>';
                    document.body.appendChild(div);
                }
                window.openCrafting = openCrafting;
                window.closeCrafting = function() {
                    const m = document.getElementById('crafting-modal');
                    if (m) m.remove();
                    isCraftingOpen = false;
                    // Ao fechar o crafting, tentar relockar o pointer para permitir movimento.
                    try {
                        if (gameStarted && controls && typeof controls.lock === 'function') {
                            controls.lock();
                        }
                        try { if (renderer && renderer.domElement) renderer.domElement.focus(); } catch(e) {}
                    } catch (err) { /* ignorar falhas silenciosamente */ }
                };
                window.craftItem = function(idx) {
                    const recipe = craftingRecipes[idx];
                    // Checa se tem os itens (leva em conta pilhas)
                        const counts = {};
                        inventory.forEach(i=>{counts[i.type]=(counts[i.type]||0)+(i.count||1);});
                    let can = true;
                    for (let k in recipe.requires) {
                        if (!counts[k] || counts[k]<recipe.requires[k]) can = false;
                    }
                    if (!can) { alert('Faltam ingredientes!'); return; }
                    // Remove ingredientes
                    for (let k in recipe.requires) {
                            let needed = recipe.requires[k];
                            for (let i=inventory.length-1;i>=0&&needed>0;i--) {
                                if (inventory[i].type===k) {
                                    const have = inventory[i].count || 1;
                                    if (have > needed) {
                                        // retira parte da pilha
                                        inventory[i].count = have - needed;
                                        needed = 0;
                                    } else {
                                        // consome a pilha inteira
                                        needed -= have;
                                        inventory.splice(i,1);
                                    }
                                }
                            }
                    }
                        // Adiciona resultado (usa addToInventory para empilhar corretamente)
                        if (recipe.result && recipe.result.type) addToInventory(recipe.result.type);
                    renderInventory();
                    alert('Item criado!');
                };
        // Gera o canvas com textura procedural para a lâmina (retorna o canvas)
        function createSwordTextureCanvas(width = 128, height = 512) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');

            // Fundo metálico
            const grad = ctx.createLinearGradient(0, 0, width, height);
            grad.addColorStop(0, '#e9eef6');
            grad.addColorStop(0.4, '#cfd8e7');
            grad.addColorStop(0.6, '#bfc8dd');
            grad.addColorStop(1, '#e6eef8');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, width, height);

            // Riscar verticalmente para simular acabamento escovado
            ctx.strokeStyle = 'rgba(255,255,255,0.06)';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 2) {
                ctx.beginPath();
                const jitter = (Math.random() - 0.5) * 0.8;
                ctx.moveTo(x + jitter, 0);
                ctx.lineTo(x + jitter, height);
                ctx.stroke();
            }

            // Adiciona algumas marcas/arranhões
            ctx.strokeStyle = 'rgba(60,60,60,0.12)';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 6; i++) {
                ctx.beginPath();
                const y = Math.random() * height;
                ctx.moveTo(5 + Math.random() * 20, y);
                ctx.lineTo(width - (5 + Math.random() * 20), y + (Math.random() - 0.5) * 12);
                ctx.stroke();
            }

            // Pequeno brilho central
            const shineGrad = ctx.createLinearGradient(width / 2 - 6, 0, width / 2 + 6, 0);
            shineGrad.addColorStop(0, 'rgba(255,255,255,0)');
            shineGrad.addColorStop(0.5, 'rgba(255,255,255,0.25)');
            shineGrad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = shineGrad;
            ctx.fillRect(width / 2 - 6, 0, 12, height);

            return canvas;
        }

        // Gera um ícone pequeno da espada com fundo transparente (para inventário)
        function createSwordIconCanvas(size = 80) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            // Use the same procedural blade texture as the world model to make the icon match.
            // Create a tall texture and draw a vertical slice into the icon canvas as the blade.
            const texW = 64, texH = 256;
            const bladeTexCanvas = createSwordTextureCanvas(texW, texH);
            // compute blade rectangle in icon
            const cx = size/2;
            const cy = size/2 + 4;
            const bladeH = Math.floor(size * 0.58);
            const bladeW = Math.max(2, Math.floor(size * 0.12));
            const bladeX = Math.floor(cx - bladeW/2);
            const bladeY = Math.floor(cy - bladeH/2 - 6);
            // draw a central vertical slice of the texture scaled to blade rect
            const sliceX = Math.floor(texW * 0.45);
            ctx.drawImage(bladeTexCanvas, sliceX, 0, 4, texH, bladeX, bladeY, bladeW, bladeH);
            // subtle highlight
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fillRect(cx - 1, bladeY, 2, bladeH);
            // Guard
            const guardW = Math.max(2, Math.floor(bladeW * 2.2));
            const guardH = Math.max(2, Math.floor(size * 0.06));
            ctx.fillStyle = '#d4b24a';
            ctx.fillRect(cx - guardW/2, bladeY + Math.floor(bladeH*0.6), guardW, guardH);
            // Handle
            const handleH = Math.max(6, Math.floor(size * 0.16));
            ctx.fillStyle = '#7a4a2d';
            ctx.fillRect(cx - Math.floor(bladeW/2), bladeY + Math.floor(bladeH*0.6) + guardH, bladeW, handleH);

            return canvas;
        }

        // Gera um ícone pequeno do machado (para inventário)
        function createAxeIconCanvas(size = 80) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0,0,size,size);
            const cx = size/2;
            const cy = size/2 + 4;

            // Handle
            ctx.fillStyle = '#7a4a2d';
            const handleW = Math.max(4, Math.floor(size * 0.08));
            const handleH = Math.max(18, Math.floor(size * 0.28));
            ctx.fillRect(cx - handleW/2 + 6, cy - handleH/2 + 6, handleW, handleH);

            // Blade
            ctx.fillStyle = '#9aa6b2';
            ctx.beginPath();
            const bx = cx - 6;
            const by = cy - 12;
            ctx.moveTo(bx, by);
            ctx.quadraticCurveTo(bx + 26, by + 8, bx, by + 26);
            ctx.lineTo(bx - 4, by + 20);
            ctx.quadraticCurveTo(bx + 12, by + 6, bx - 4, by);
            ctx.fill();

            // small highlight
            ctx.fillStyle = 'rgba(255,255,255,0.25)';
            ctx.fillRect(bx + 2, by + 6, 6, 2);

            return canvas;
        }

        // Cria um THREE.CanvasTexture a partir do canvas e reaplica se necessário
        function createSwordTexture(width = 128, height = 512) {

            const canvas = createSwordTextureCanvas(width, height);
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 1);
            tex.needsUpdate = true;
            // Reaplica se já estiver equipada
            applySwordTextureToExistingMesh(tex);
            return tex;
        }

        // Reaplica a textura na lâmina caso a espada já esteja equipada
        function applySwordTextureToExistingMesh(tex) {
            if (!swordMesh) return;
            swordMesh.traverse(child => {
                if (child.isMesh && child.geometry && child.material) {
                    const p = child.geometry.parameters || {};
                    if (p.height && Math.abs(p.height - 0.8) < 0.4) {
                        child.material.map = tex;
                        child.material.metalness = 0.9;
                        child.material.roughness = 0.25;
                        child.material.needsUpdate = true;
                    }
                }
            });
        }

        // Exibe a espada na mão do jogador (câmera)
        function showSwordInHand() {
            // Se já existe a malha da espada, apenas gere e aplique a textura novamente
            if (swordMesh) { createSwordTexture(64, 512); return; }
            // Lâmina
            const bladeGeo = new THREE.BoxGeometry(0.12, 0.8, 0.12);
            const bladeTexture = createSwordTexture(64, 512);
            const bladeMat = new THREE.MeshStandardMaterial({ map: bladeTexture, metalness: 0.9, roughness: 0.25 });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.32;
            // Cabo
            const handleGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.28, 8);
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.28;
            // Guarda
            const guardGeo = new THREE.BoxGeometry(0.22, 0.06, 0.22);
            const guardMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const guard = new THREE.Mesh(guardGeo, guardMat);
            guard.position.y = 0.01;
            // Agrupar
            swordMesh = new THREE.Group();
            swordMesh.add(blade);
            swordMesh.add(handle);
            swordMesh.add(guard);
            // Posição e rotação para "mão direita" do jogador
            swordMesh.position.set(0.38, -0.45, -0.7);
            swordMesh.rotation.x = Math.PI / 7;
            swordMesh.rotation.y = Math.PI / 8;
            swordMesh.rotation.z = Math.PI / 2.1;
            camera.add(swordMesh);
        }

        function hideSwordInHand() {
            if (swordMesh) {
                camera.remove(swordMesh);
                swordMesh = null;
            }
        }

        // Exibe o machado na mão do jogador (câmera)
        function showAxeInHand() {
            if (axeMesh) return;
            const bladeGeo = new THREE.BoxGeometry(0.5, 0.18, 0.9);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xb0bcc3, metalness: 0.4, roughness: 0.4 });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.set(-0.06, 0.05, -0.2);
            blade.rotation.z = -Math.PI / 6;

            const handleGeo = new THREE.CylinderGeometry(0.06, 0.06, 0.9, 8);
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x7a4a2d });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.set(0.24, -0.25, -0.6);
            handle.rotation.x = Math.PI / 2.8;

            axeMesh = new THREE.Group();
            axeMesh.add(blade);
            axeMesh.add(handle);
            axeMesh.position.set(0.38, -0.45, -0.7);
            axeMesh.rotation.x = Math.PI / 9;
            axeMesh.rotation.y = Math.PI / 10;
            camera.add(axeMesh);
        }

        function hideAxeInHand() {
            if (axeMesh) {
                camera.remove(axeMesh);
                axeMesh = null;
            }
        }

        // --- LÓGICA DE JOGO ---

        function checkInteraction() {
            if (isInventoryOpen) return; // Não pega itens se inv estiver aberto

            const playerPos = controls.getObject().position;
            let found = false;

            for (let i = 0; i < itemsInWorld.length; i++) {
                const item = itemsInWorld[i];
                if (!item.userData.active) continue;

                if (playerPos.distanceTo(item.position) < 4) {
                    addToInventory(item.userData.type);

                    // Remove da cena
                    item.visible = false; // Apenas esconde para performance
                    item.userData.active = false;
                    found = true;
                    break;
                }
            }
        }

        function updateHUD() {
            document.getElementById('health-bar').style.width = health + '%';
            document.getElementById('hunger-bar').style.width = hunger + '%';
            document.getElementById('thirst-bar').style.width = thirst + '%';
            const sBar = document.getElementById('stamina-bar');
            if (sBar) sBar.style.width = Math.max(0, Math.min(100, stamina)) + '%';
        }

        // Variáveis de Física
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let canJump = false;

        function animate() {
            requestAnimationFrame(animate);
                        // Atualizar barras de vida dos inimigos
                        const barsContainer = document.getElementById('enemies-health-bars');
                        enemies.forEach(enemy => {
                            if (!enemy.userData.healthBarId) return;
                            // Projeta posição 3D para 2D
                            const pos = enemy.position.clone();
                            pos.y += 2.2; // Acima da cabeça
                            pos.project(camera);
                            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                            const bar = enemy.userData.healthBarId;
                            // centralizamos o elemento usando translate(-50%, -110%), então posicionamos no ponto projetado
                            bar.style.left = x + 'px';
                            bar.style.top = (y - 12) + 'px';
                                // Atualiza vida e visibilidade somente se estiver perto do jogador
                                const inner = bar.querySelector('.enemy-health-inner');
                                const percent = Math.max(0, enemy.userData.health / enemy.userData.maxHealth);
                                if (inner) inner.style.width = (percent * 100) + '%';
                                const playerPos = controls.getObject().position;
                                const ENEMY_BAR_SHOW_DISTANCE = 20; // ajustar conforme desejado
                                const distToPlayer = enemy.position.distanceTo(playerPos);
                                // Verifica se o jogador está olhando para o inimigo
                                const forward = new THREE.Vector3();
                                camera.getWorldDirection(forward);
                                // Ignora componente Y para considerar apenas direção horizontal (XZ)
                                forward.y = 0;
                                if (forward.lengthSq() > 0) forward.normalize();
                                const toEnemy = enemy.position.clone().sub(playerPos);
                                toEnemy.y = 0;
                                let facing = false;
                                if (toEnemy.lengthSq() > 0) {
                                    toEnemy.normalize();
                                    const DOT_THRESHOLD = 0.7; // ~45 graus de tolerância
                                    facing = forward.dot(toEnemy) > DOT_THRESHOLD;
                                }
                                bar.style.display = (enemy.userData.alive && percent > 0 && distToPlayer < ENEMY_BAR_SHOW_DISTANCE && facing) ? 'block' : 'none';
                        });

            const time = performance.now();
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            updateDayNight(delta);
            // Detect day/night cycle wrap (completed a full cycle) and decrement slow-decay timer
            if (previousTimeOfDay > timeOfDay) {
                if (slowDecayActive) {
                    slowDecayCyclesLeft -= 1;
                    if (slowDecayCyclesLeft <= 0) {
                        slowDecayActive = false;
                    }
                }
            }
            previousTimeOfDay = timeOfDay;

            // Só processa lógica se não estiver pausado e não estiver no inventário
            // Mas hunger/thirst continuam caindo? Em jogos survival, geralmente sim.
            // Aqui vamos pausar o movimento, mas manter o status caindo.
            
            if (!isInventoryOpen && controls.isLocked) {
                // Diminuição de status (aplica multiplicador se slowDecay estiver ativo)
                const decayMultiplier = slowDecayActive ? SLOW_DECAY_FACTOR : 1.0;
                hunger -= 1.0 * decayMultiplier * delta;
                thirst -= 1.5 * decayMultiplier * delta;

                if (hunger <= 0 || thirst <= 0) health -= 3 * delta;
                if (health <= 0) {
                    health = 0;
                    controls.unlock();
                    alert("Você morreu de fome/sede!");
                    location.reload();
                }
                updateHUD();

                // Movimento
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 10.0 * delta; // Gravidade

                direction.z = Number(!!keyState['KeyW'] || !!keyState['ArrowUp']) - Number(!!keyState['KeyS'] || !!keyState['ArrowDown']);
                direction.x = Number(!!keyState['KeyD'] || !!keyState['ArrowRight']) - Number(!!keyState['KeyA'] || !!keyState['ArrowLeft']);
                direction.normalize();

                // Movimentação: walking vs sprint
                const moving = (keyState['KeyW'] || keyState['KeyS'] || keyState['ArrowUp'] || keyState['ArrowDown'] || keyState['KeyA'] || keyState['KeyD'] || keyState['ArrowLeft'] || keyState['ArrowRight']);
                const wantSprint = (keyState['ShiftLeft'] || keyState['ShiftRight']);

                // Decide se está correndo: tem stamina e está tentando sprintar e movendo
                isSprinting = wantSprint && stamina > 0 && moving;

                let currentSpeed = WALK_SPEED;
                if (isSprinting) currentSpeed = SPRINT_SPEED;
                else if (stamina <= 0) currentSpeed = WALK_SPEED_EXHAUSTED;

                if (keyState['KeyW'] || keyState['KeyS'] || keyState['ArrowUp'] || keyState['ArrowDown']) 
                    velocity.z -= direction.z * currentSpeed * delta;
                if (keyState['KeyD'] || keyState['KeyA'] || keyState['ArrowRight'] || keyState['ArrowLeft']) 
                    velocity.x -= direction.x * currentSpeed * delta;

                // Stamina drain / regen
                if (isSprinting) {
                    stamina -= STAMINA_DRAIN * delta;
                    if (stamina < 0) stamina = 0;
                } else {
                    // Regenerates over time when not sprinting
                    stamina += STAMINA_REGEN * delta;
                    if (stamina > MAX_STAMINA) stamina = MAX_STAMINA;
                }
                // Atualiza HUD para refletir stamina atual
                updateHUD();

                // Pulo
                if (keyState['Space'] && canJump) {
                    velocity.y += 25;
                    canJump = false;
                }

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                // Colisão Terreno
                const pos = controls.getObject().position;
                
                // Limites do mapa
                if (pos.x < -WORLD_WIDTH/2) pos.x = -WORLD_WIDTH/2;
                if (pos.x > WORLD_WIDTH/2) pos.x = WORLD_WIDTH/2;
                if (pos.z < -WORLD_DEPTH/2) pos.z = -WORLD_DEPTH/2;
                if (pos.z > WORLD_DEPTH/2) pos.z = WORLD_DEPTH/2;

                const terrainH = getNoiseHeight(pos.x, pos.z);
                if (pos.y < terrainH + PLAYER_HEIGHT) {
                    velocity.y = 0;
                    pos.y = terrainH + PLAYER_HEIGHT;
                    canJump = true;
                }
            }

            // Animação dos itens (girar) — usa baseY para evitar acúmulo vertical
            itemsInWorld.forEach(item => {
                if (item.userData.active) {
                    item.rotation.y += delta;
                    const bob = Math.sin(time * 0.003 + (item.userData.phase || 0)) * 0.25; // amplitude em unidades
                    item.position.y = (item.userData.baseY !== undefined ? item.userData.baseY : item.position.y) + bob;
                }
            });

            // INIMIGOS: movimentação simples e dano
            if (!isInventoryOpen && controls.isLocked) {
                const playerPos = controls.getObject().position;
                enemies.forEach(enemy => {
                    if (!enemy.userData.alive) return;
                    // Movimento simples: segue o jogador se perto
                    const dist = enemy.position.distanceTo(playerPos);
                    if (dist < 30 && dist > 2.5) {
                        const dir = new THREE.Vector3().subVectors(playerPos, enemy.position).normalize();
                        const spd = (enemy.userData && enemy.userData.speed) ? enemy.userData.speed : 3.5;
                        enemy.position.x += dir.x * delta * spd;
                        enemy.position.z += dir.z * delta * spd;
                        // Ajusta altura ao terreno
                        const terrainY = (typeof sampleHeight === 'function') ? sampleHeight(enemy.position.x, enemy.position.z) : getNoiseHeight(enemy.position.x, enemy.position.z);
                        // vertical offset depends on enemy height; keep roughly grounded
                        enemy.position.y = terrainY + (enemy.userData && enemy.userData.kind === 'zombie' ? 1.2 : 1);
                    }
                    // Dano ao jogador
                    if (dist < 2.2) {
                        health -= enemy.userData.damage * delta;
                        updateHUD();
                    }
                });
            }
            
            // Check mensagem 'E'
            if (!isInventoryOpen && controls.isLocked) {
                const msg = document.getElementById('interaction-msg');
                const pos = controls.getObject().position;
                let near = false;
                for(let item of itemsInWorld) {
                    if(item.userData.active && item.position.distanceTo(pos) < 4) {
                        near = true; break;
                    }
                }
                // Só altera se não estiver mostrando a mensagem de "Pegou Item"
                if (!msg.innerText.includes('Pegou')) {
                    msg.style.display = near ? 'block' : 'none';
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // animate(); -- iniciará somente quando o jogador clicar em 'Começar'

        // Tecla C para abrir crafting (mostra o cursor/modal)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyC') openCrafting();
        });

        // Ataque com espada (deve estar dentro do script)
        window.addEventListener('mousedown', (e) => {
            if (!equippedSword || isInventoryOpen || !controls.isLocked) return;
            // Ataque: verifica inimigos próximos à frente
            const playerPos = controls.getObject().position.clone();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            let hit = false;
            enemies.forEach(enemy => {
                if (!enemy.userData.alive || enemy.userData.health <= 0) return;
                const toEnemy = enemy.position.clone().sub(playerPos);
                const dist = toEnemy.length();
                // Ângulo entre frente e inimigo
                const angle = forward.angleTo(toEnemy.normalize());
                if (dist < 3.2 && angle < Math.PI / 4) {
                    // Dano
                    enemy.userData.health -= 40;
                    if (enemy.userData.health <= 0) {
                        enemy.userData.alive = false;
                        enemy.visible = false;
                    }
                    hit = true;
                }
            });
            if (hit) {
                // Animação simples de "ataque"
                if (swordMesh) {
                    swordMesh.rotation.x -= 0.7;
                    setTimeout(() => { if (swordMesh) swordMesh.rotation.x += 0.7; }, 120);
                }
            }
        });

    </script>
</body>
</html>
