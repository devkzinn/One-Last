<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>One Last</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; }
        
        /* UI Overlay - HUD Principal */
        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            padding: 20px;
            box-sizing: border-box;
            z-index: 10;
        }

        /* Tela de Bloqueio / Menu Inicial */
        #blocker {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(20,30,40,0.95); /* cor de fundo mais agradável */
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 999;
            color: white;
            text-align: center;
        }
        #instructions { font-size: 24px; cursor: pointer; }
        
        /* INVENTÁRIO (NOVO) */
        #inventory-container {
            display: none; /* Escondido por padrão */
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            height: 400px;
            background: rgba(20, 20, 20, 0.95);
            border: 2px solid #555;
            border-radius: 10px;
            padding: 20px;
            z-index: 100; /* Acima do HUD */
            pointer-events: auto; /* Permite clicar */
            color: white;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #inventory-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 20px;
            height: 300px;
            overflow-y: auto;
        }

        .inv-slot {
            width: 80px;
            height: 80px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #444;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
        }
        .inv-slot:hover { background: rgba(255,255,255,0.2); border-color: white; }
        
        /* Ícones simples via CSS para os itens */
        .icon-food { width: 30px; height: 30px; background: #e74c3c; border-radius: 4px; margin-bottom: 5px; box-shadow: 2px 2px 0px rgba(0,0,0,0.3); }
        .icon-water { width: 30px; height: 30px; background: #3498db; border-radius: 50%; margin-bottom: 5px; box-shadow: 2px 2px 0px rgba(0,0,0,0.3); }
        .icon-sword { width: 30px; height: 30px; margin-bottom: 5px; position: relative; }
        .icon-sword::before {
            content: '';
            display: block;
            position: absolute;
            left: 13px; top: 3px;
            width: 4px; height: 22px;
            background: linear-gradient(180deg, #eee 70%, #888 100%);
            border-radius: 2px;
            box-shadow: 1px 1px 2px #222;
        }
        .icon-sword::after {
            content: '';
            display: block;
            position: absolute;
            left: 8px; top: 22px;
            width: 14px; height: 4px;
            background: #b48a3c;
            border-radius: 2px;
            box-shadow: 1px 1px 2px #222;
        }
        
        .item-count { font-size: 12px; color: #ccc; }
        .close-btn { position: absolute; top: 10px; right: 15px; cursor: pointer; font-weight: bold; font-size: 20px; color: #e74c3c; }

        /* Estilo das Barras de Status */
        .stat-box {
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 8px;
            width: 300px;
            margin-bottom: 10px;
        }
        .stat-label { color: white; font-weight: bold; margin-bottom: 5px; font-size: 14px; }
        .bar-container { width: 100%; height: 20px; background-color: #333; border-radius: 4px; overflow: hidden; }
        .bar-fill { height: 100%; width: 100%; transition: width 0.2s; }
        /* Barras de vida dos inimigos (fina, nome em cima) */
        .enemy-health-bar { position: absolute; pointer-events: none; display: none; transform: translate(-50%, -110%); z-index: 30; text-align: center; }
        .enemy-name { color: white; font-size: 12px; font-weight: 300; margin-bottom: 3px; text-shadow: 0 1px 2px rgba(0,0,0,0.7); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .enemy-health-outer { width: 80px; height: 8px; background: rgba(0,0,0,0.45); border-radius: 4px; overflow: hidden; border: 1px solid rgba(255,255,255,0.06); }
        .enemy-health-inner { height: 100%; width: 100%; transition: width 0.12s linear; border-radius: 3px; }
        
        #health-bar { background-color: #e74c3c; } 
        #hunger-bar { background-color: #e67e22; } 
        #thirst-bar { background-color: #3498db; } 
        #stamina-bar { background-color: #9b59b6; }

        #interaction-msg {
            position: absolute;
            top: 55%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            display: none;
            background: rgba(0,0,0,0.4);
            padding: 5px 10px;
            border-radius: 4px;
        }
        /* HUD de status — oculto até iniciar o jogo */
        #top-hud { position: absolute; top: 20px; left: 20px; pointer-events: none; display: none; flex-direction: column; align-items: flex-start; z-index: 11; }
        #status-hud { position: absolute; bottom: 20px; left: 20px; pointer-events: none; display: none; flex-direction: column; align-items: flex-start; z-index: 10; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
</head>
<body>

    <div id="blocker">
        <div id="instructions">
            <h1 style="margin:0;">One Last</h1>
            <!-- menu tagline removed as requested -->
            <div style="margin-top:18px;">
                <button id="start-btn" style="padding:12px 24px;margin:8px;font-size:18px;cursor:pointer;">Começar</button>
                <button id="resume-btn" style="padding:12px 24px;margin:8px;font-size:18px;cursor:pointer;display:none;">Retomar</button>
                <button id="tutorial-btn" style="padding:12px 18px;margin:8px;font-size:18px;cursor:pointer;">Tutorial</button>
            </div>
            <div style="margin-top:20px;font-size:14px;opacity:0.85;">Pressione Começar para iniciar sua jornada.</div>
        </div>
    </div>

    <!-- Barras de vida dos inimigos -->
    <div id="enemies-health-bars" style="position:absolute;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:20;"></div>

    <div id="inventory-container">
        <h2 style="margin:0;">Mochila</h2>
        <div class="close-btn" onclick="closeInventory()">X</div>
        <div style="font-size: 12px; color: #aaa;">Clique no item para usar</div>
        <div id="inventory-grid">
            </div>
    </div>

    <div id="ui-layer">
        <div id="interaction-msg">Pressione 'E' para pegar</div>

        <div id="top-hud">
            <div class="stat-box">
                <div class="stat-label">VIDA</div>
                <div class="bar-container"><div id="health-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
            <div class="stat-box">
                <div class="stat-label">STAMINA</div>
                <div class="bar-container"><div id="stamina-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
        </div>

        <div id="status-hud">
            <div class="stat-box">
                <div class="stat-label">FOME</div>
                <div class="bar-container"><div id="hunger-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
            <div class="stat-box">
                <div class="stat-label">SEDE</div>
                <div class="bar-container"><div id="thirst-bar" class="bar-fill" style="width: 100%;"></div></div>
            </div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CICLO DIA/NOITE ---
        let timeOfDay = 0; // 0 a 1 (0 = manhã, 0.5 = noite, 1 = manhã)
        function updateDayNight(delta) {
            timeOfDay += delta * 0.01; // 1 ciclo = ~100s
            if (timeOfDay > 1) timeOfDay -= 1;
            // Luz ambiente e cor do céu
            const t = Math.abs(Math.sin(timeOfDay * Math.PI));
            scene.background.setHSL(0.6, 0.7, 0.5 * t + 0.1);
            scene.fog.color.setHSL(0.6, 0.7, 0.5 * t + 0.1);
            hemiLight.intensity = 0.2 + 0.6 * t;
            dirLight.intensity = 0.2 + 0.8 * t;
            dirLight.position.y = 100 * t + 10;
        }

        // --- CONFIGURAÇÕES GERAIS ---
        const WORLD_WIDTH = 200;
        const WORLD_DEPTH = 200;
        const TERRAIN_MAX_HEIGHT = 15;
        const PLAYER_HEIGHT = 2.5; 
        
        // --- ESTADO DO JOGO ---
        let health = 100;
        let hunger = 100;
        let thirst = 100;
        // Stamina / Sprint
        let stamina = 100;
        const MAX_STAMINA = 100;
        const STAMINA_DRAIN = 20; // units per second while sprinting
        const STAMINA_REGEN = 12; // units per second when not sprinting
        const WALK_SPEED = 100.0; // normal walking speed
        const SPRINT_SPEED = 220.0; // previous MOVE_SPEED becomes sprint speed
        const WALK_SPEED_EXHAUSTED = 60.0; // slowed when stamina is 0
        let isSprinting = false;
        // Slow decay (hunger/thirst slower) for limited day/night cycles
        let slowDecayActive = false;
        let slowDecayCyclesLeft = 0; // number of full day/night cycles remaining
        let SLOW_DECAY_FACTOR = 0.5; // multiplier applied to depletion rates while active (0.5 => half rate)
        let previousTimeOfDay = timeOfDay;
        function enableSlowDecay(cycles = 3, factor = 0.5) {
            slowDecayActive = true;
            slowDecayCyclesLeft = cycles;
            SLOW_DECAY_FACTOR = factor;
        }
        let lastTime = performance.now();
        let gameStarted = false;
        
        // Inventário: Array simples de objetos { type: 'food', name: 'Maçã' }
        let inventory = [];
        let isInventoryOpen = false;
        let equippedSword = false;
        let swordMesh = null;
        
        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 10, 90);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        // Mantém o canvas oculto até o jogador clicar em "Começar"
        renderer.domElement.style.display = 'none';

        // Luzes
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 100, 50);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        scene.add(dirLight);

        // --- TERRENO ---
        const simplex = new SimplexNoise();
        const geometry = new THREE.PlaneGeometry(WORLD_WIDTH, WORLD_DEPTH, 120, 120);
        geometry.rotateX(-Math.PI / 2);

        const vertices = geometry.attributes.position.array;
        const colors = [];

        function getNoiseHeight(x, z) {
            // Suavização: usar frequências menores e interpolação
            let y1 = simplex.noise2D(x * 0.012, z * 0.012) * (TERRAIN_MAX_HEIGHT * 0.7);
            let y2 = simplex.noise2D(x * 0.04, z * 0.04) * (TERRAIN_MAX_HEIGHT * 0.2);
            let y3 = simplex.noise2D(x * 0.12, z * 0.12) * (TERRAIN_MAX_HEIGHT * 0.08);
            let y = y1 + y2 + y3;
            // Interpolação para suavizar ainda mais
            y = (y + simplex.noise2D((x+1) * 0.012, (z+1) * 0.012) * (TERRAIN_MAX_HEIGHT * 0.7)) / 2;
            return Math.max(-10, y);
        }

        for (let i = 0; i < vertices.length; i += 3) {
            const x = vertices[i];
            const z = vertices[i + 2];
            const y = getNoiseHeight(x, z);
            vertices[i + 1] = y;

            if (y < -2) colors.push(0.76, 0.7, 0.5); // Areia
            else if (y < 8) colors.push(0.2, 0.8, 0.2); // Grama
            else colors.push(0.5, 0.5, 0.5); // Pedra
        }

        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.computeVertexNormals();

        const terrainMat = new THREE.MeshStandardMaterial({ 
            vertexColors: true, flatShading: true, roughness: 0.8 
        });
        const terrain = new THREE.Mesh(geometry, terrainMat);
        terrain.receiveShadow = true;
        scene.add(terrain);

        // Posição inicial da câmera (acima do terreno)
        const initY = getNoiseHeight(0, 0) + PLAYER_HEIGHT + 2;
        camera.position.set(0, initY, 30);


        // --- BLOCOS (MINERAÇÃO/COLOCAÇÃO) ---
        const blockSize = 2;
        const blocks = [];
        const blockTypes = [
            { type: 'dirt', color: 0x8B5A2B },
            { type: 'stone', color: 0x888888 },
            { type: 'sand', color: 0xEED28A }
        ];
        // Adiciona alguns blocos no mundo para teste (alinha ao terreno)
        for (let i = 0; i < 30; i++) {
            const t = blockTypes[Math.floor(Math.random()*blockTypes.length)];
            const mesh = new THREE.Mesh(
                new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                new THREE.MeshStandardMaterial({ color: t.color })
            );
            const x = (Math.random()-0.5)*60;
            const z = (Math.random()-0.5)*60;
            const terrainY = getNoiseHeight(x, z);
            // posiciona o bloco alinhado ao chão (meio do bloco sobre o terreno)
            mesh.position.set(x, terrainY + blockSize/2, z);
            mesh.castShadow = true;
            mesh.userData = { type: t.type };
            scene.add(mesh);
            blocks.push(mesh);
        }

        // --- OBJETOS ---
        const itemsInWorld = [];

        // --- INIMIGOS ---
        const enemies = [];
        function spawnEnemy(x, z, y, kind) {
            // Monstros: 'vampiro' | 'Lobisomen' | 'zombie'
            const kinds = ['vampiro', 'Lobisomen', 'zombie'];
            const k = kind || kinds[Math.floor(Math.random() * kinds.length)];

            let enemyGeo, enemyMat, color = 0x990000, speed = 3.5, damage = 12, maxHealth = 100, scaleY = 2;
            if (k === 'vampiro') {
                color = 0x8e44ad; // purple-ish
                speed = 4.5; // rápido
                damage = 18; // razoável
                maxHealth = 100;
                enemyGeo = new THREE.BoxGeometry(0.9, 1.8, 0.9);
            } else if (k === 'Lobisomen') {
                color = 0x333333; // dark
                speed = 6.0; // muito rápido
                damage = 8; // fraco
                maxHealth = 220;
                enemyGeo = new THREE.BoxGeometry(1.0, 1.9, 1.0);
            } else { // zombie
                color = 0x2e8b57; // green-ish
                speed = 1.0; // muito lento
                damage = 36; // muito forte
                maxHealth = 80;
                enemyGeo = new THREE.BoxGeometry(1.1, 2.4, 1.1);
            }

            enemyMat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.6 });
            const enemy = new THREE.Mesh(enemyGeo, enemyMat);
            enemy.position.set(x, y + (scaleY/2 || 1), z);
            enemy.castShadow = true;
            // Vida máxima e atual + speed e tipo
            enemy.userData = { kind: k, alive: true, damage: damage, maxHealth: maxHealth, health: maxHealth, speed: speed, healthBarId: null };
            scene.add(enemy);
            enemies.push(enemy);
            // Criar barra de vida HTML mais sofisticada (nome + barra fina)
            const bar = document.createElement('div');
            bar.className = 'enemy-health-bar';
            const nameDiv = document.createElement('div');
            nameDiv.className = 'enemy-name';
            nameDiv.innerText = (k === 'vampiro') ? 'Vampiro' : (k === 'Lobisomen') ? 'Lobisomem' : 'Zumbi';
            bar.appendChild(nameDiv);
            const outer = document.createElement('div');
            outer.className = 'enemy-health-outer';
            const inner = document.createElement('div');
            inner.className = 'enemy-health-inner';
            // color inner by type for quick feedback
            if (k === 'vampiro') inner.style.background = '#b368d6';
            else if (k === 'Lobisomen') inner.style.background = '#999999';
            else inner.style.background = '#66aa66';
            inner.style.width = '100%';
            outer.appendChild(inner);
            bar.appendChild(outer);
            document.getElementById('enemies-health-bars').appendChild(bar);
            enemy.userData.healthBarId = bar;
        }

        // Spawnar alguns inimigos
        for (let i = 0; i < 8; i++) {
            const x = (Math.random() - 0.5) * 160;
            const z = (Math.random() - 0.5) * 160;
            const y = getNoiseHeight(x, z);
            if (y > 1) spawnEnemy(x, z, y);
        }

        function spawnTree(x, z, y) {
            const treeGroup = new THREE.Group();
            
            const trunkGeo = new THREE.CylinderGeometry(0.4, 0.6, 2.5, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513, flatShading: true });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 1.25;
            trunk.castShadow = true;
            treeGroup.add(trunk);

            const leavesGeo = new THREE.ConeGeometry(2.5, 5, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x228B22, flatShading: true });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 4.0; 
            leaves.castShadow = true;
            treeGroup.add(leaves);

            treeGroup.position.set(x, y, z);
            scene.add(treeGroup);
        }

        function spawnItem(type, x, z, y) {
            let geometry, material, color;
            if (type === 'food') { 
                geometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                color = 0xFF4444;
            } else if (type === 'water') { 
                geometry = new THREE.SphereGeometry(0.4, 8, 8);
                color = 0x4444FF;
            } else if (type === 'sword') {
                geometry = new THREE.BoxGeometry(0.15, 1.1, 0.15);
                color = 0xcccccc;
            }
            material = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2 });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y + 0.8, z);
            mesh.castShadow = true;
            // guarda a posição base para animação vertical estável
            mesh.userData = { type: type, active: true, baseY: mesh.position.y, phase: Math.random() * Math.PI * 2 };
            scene.add(mesh);
            itemsInWorld.push(mesh);
        }

        // Popular
        for (let i = 0; i < 100; i++) {
            const x = (Math.random() - 0.5) * 180;
            const z = (Math.random() - 0.5) * 180;
            const y = getNoiseHeight(x, z);

            if (y > 0.5) {
                const r = Math.random();
                if (r < 0.55) spawnTree(x, z, y);
                else if (r < 0.75) spawnItem('food', x, z, y);
                else if (r < 0.93) spawnItem('water', x, z, y);
                else spawnItem('sword', x, z, y);
            }
        }

        // --- CONTROLES E SISTEMA DE JOGO ---
        const controls = new PointerLockControls(camera, document.body);
        // Posiciona o objeto de controle (jogador) acima do terreno no início
        controls.getObject().position.set(0, getNoiseHeight(0, 0) + PLAYER_HEIGHT, 30);
        
        const blocker = document.getElementById('blocker');
        const instructions = document.getElementById('instructions');
        const startBtn = document.getElementById('start-btn');
        const resumeBtn = document.getElementById('resume-btn');
        const tutorialBtn = document.getElementById('tutorial-btn');
        const invContainer = document.getElementById('inventory-container');

        // Estado das teclas
        const keyState = {};

        // Botões do menu
        startBtn.addEventListener('click', function () { startGame(); });
        resumeBtn.addEventListener('click', function () { controls.lock(); blocker.style.display = 'none'; });
        tutorialBtn.addEventListener('click', function () { openTutorial(); });

        // Eventos do PointerLock
        controls.addEventListener('lock', function () {
            blocker.style.display = 'none';
            invContainer.style.display = 'none';
            isInventoryOpen = false;
        });

        controls.addEventListener('unlock', function () {
            // Se o inventário estiver aberto, NÃO mostra o menu de bloqueio
            if (isInventoryOpen) {
                blocker.style.display = 'none';
                invContainer.style.display = 'block';
                renderInventory();
            } else {
                blocker.style.display = 'flex';
                instructions.style.display = '';
                invContainer.style.display = 'none';
                // Se o jogo já tinha começado, mostramos o botão 'Retomar' em vez de 'Começar'
                if (gameStarted) {
                    startBtn.style.display = 'none';
                    resumeBtn.style.display = '';
                } else {
                    startBtn.style.display = '';
                    resumeBtn.style.display = 'none';
                }
            }
        });

        // Função para iniciar o jogo (mostra o canvas e inicia o loop)
        function startGame() {
            if (gameStarted) return;
            renderer.domElement.style.display = '';
            // Inicia loop de animação e travamento de ponteiro
            animate();
            controls.lock();
            // Mostrar HUD de status quando o jogo iniciar
            const hud = document.getElementById('status-hud');
            const topHud = document.getElementById('top-hud');
            if (hud) hud.style.display = 'flex';
            if (topHud) topHud.style.display = 'flex';
            // Ativa redução de taxa de fome/sede por até 3 ciclos (dias+noites)
            enableSlowDecay(3, 0.5);
            gameStarted = true;
        }

        // Modal de tutorial
        function openTutorial() {
            if (document.getElementById('tutorial-modal')) return;
            const div = document.createElement('div');
            div.id = 'tutorial-modal';
            div.style = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#111;color:#fff;padding:24px;z-index:1000;border-radius:10px;max-width:600px;';
            div.innerHTML = `
                <h2 style="margin-top:0;">Tutorial</h2>
                <p>(W, A, S, D) Mover | (ESPAÇO) Pular</p>
                <p>(E) Pegar Items | (I) Abrir Inventário</p>
                <p>(C) Abrir Crafting | (ESC) Menu / Sair do Jogo</p>
                <div style="text-align:right;margin-top:12px;"><button id="close-tutorial" style="padding:8px 12px;">Fechar</button></div>
            `;
            document.body.appendChild(div);
            document.getElementById('close-tutorial').addEventListener('click', () => { div.remove(); });
        }

        // Controles de Teclado
        document.addEventListener('keydown', (e) => {
            keyState[e.code] = true;

            if (e.code === 'KeyE') checkInteraction();
            if (e.code === 'KeyI' || e.code === 'Tab') {
                e.preventDefault(); // Evita tab mudar foco do navegador
                toggleInventory();
            }
            // Se o jogador apertar ESC enquanto o jogo está iniciado e o pointer estiver desbloqueado, tente relockar (user gesture)
            if (e.code === 'Escape') {
                if (!controls.isLocked && gameStarted) {
                    // Tentar travar novamente; alguns navegadores podem exigir clique, mas tentamos
                    try { controls.lock(); } catch (err) {}
                }
            }
        });
        document.addEventListener('keyup', (e) => keyState[e.code] = false);

        // --- LÓGICA DE INVENTÁRIO ---

        function toggleInventory() {
            if (isInventoryOpen) {
                // Fecha
                isInventoryOpen = false;
                invContainer.style.display = 'none';
                controls.lock(); // Volta a travar o mouse para o jogo
            } else {
                // Abre
                isInventoryOpen = true;
                controls.unlock(); // Solta o mouse para clicar na UI
                // O evento 'unlock' cuidará de mostrar a div
            }
        }
        
        // Torna a função global para o botão 'X' do HTML funcionar
        window.closeInventory = function() {
            if(isInventoryOpen) toggleInventory();
        };

        function addToInventory(type) {
            let name = '';
            if (type === 'food') name = 'Maçã';
            else if (type === 'water') name = 'Água';
            else if (type === 'sword') name = 'Espada';
            else if (type === 'dirt') name = 'Terra';
            else if (type === 'stone') name = 'Pedra';
            else if (type === 'sand') name = 'Areia';
            inventory.push({
                type: type,
                name: name,
                id: Date.now() + Math.random() // ID único
            });
            // Feedback visual simples
            const msg = document.getElementById('interaction-msg');
            let msgName = name;
            msg.innerText = `Pegou: ${msgName}`;
            msg.style.display = 'block';
            setTimeout(() => { 
                if(!isInventoryOpen) msg.style.display = 'none'; 
                msg.innerText = "Pressione 'E' para pegar";
            }, 2000);
        }

        function renderInventory() {
            const grid = document.getElementById('inventory-grid');
            grid.innerHTML = '';
            if (inventory.length === 0) {
                grid.innerHTML = '<div style="grid-column: span 5; text-align:center; padding: 20px;">Mochila vazia</div>';
                return;
            }
            inventory.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = 'inv-slot';
                let iconClass = '';
                if (item.type === 'food') iconClass = 'icon-food';
                else if (item.type === 'water') iconClass = 'icon-water';
                else if (item.type === 'sword') iconClass = 'icon-sword';
                else if (item.type === 'dirt') iconClass = '';
                else if (item.type === 'stone') iconClass = '';
                else if (item.type === 'sand') iconClass = '';
                slot.innerHTML = `
                    <div class="${iconClass}" style="width:30px;height:30px;background:${item.type==='dirt'?'#8B5A2B':item.type==='stone'?'#888':'#EED28A'};border-radius:4px;margin-bottom:5px;"></div>
                    <span class="item-count">${item.name}</span>
                `;
                slot.onclick = () => useItem(index);
                grid.appendChild(slot);
            });
        }

        function useItem(index) {
            const item = inventory[index];
            if (item.type === 'food') {
                hunger = Math.min(100, hunger + 30);
                health = Math.min(100, health + 5);
                inventory.splice(index, 1);
            } else if (item.type === 'water') {
                thirst = Math.min(100, thirst + 30);
                health = Math.min(100, health + 2);
                inventory.splice(index, 1);
            } else if (item.type === 'sword') {
                if (!equippedSword) {
                    equippedSword = true;
                    showSwordInHand();
                    alert('Espada equipada! Clique para atacar.');
                } else {
                    equippedSword = false;
                    hideSwordInHand();
                    alert('Espada guardada!');
                }
            } else if (item.type === 'dirt' || item.type === 'stone' || item.type === 'sand') {
                // Colocar bloco no mundo
                placeBlock(item.type);
                inventory.splice(index, 1);
            }
            updateHUD();
            renderInventory();
                // Colocação de bloco
                function placeBlock(type) {
                    // Posição à frente do jogador
                    const pos = controls.getObject().position.clone();
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    dir.multiplyScalar(4);
                    const placePos = pos.add(dir);
                    // Alinha à grade
                    const bx = Math.round(placePos.x / blockSize) * blockSize;
                    const by = Math.round((placePos.y-PLAYER_HEIGHT) / blockSize) * blockSize + blockSize/2 + PLAYER_HEIGHT;
                    const bz = Math.round(placePos.z / blockSize) * blockSize;
                    const t = blockTypes.find(b=>b.type===type);
                    if (!t) return;
                    const mesh = new THREE.Mesh(
                        new THREE.BoxGeometry(blockSize, blockSize, blockSize),
                        new THREE.MeshStandardMaterial({ color: t.color })
                    );
                    mesh.position.set(bx, by, bz);
                    mesh.castShadow = true;
                    mesh.userData = { type: t.type };
                    scene.add(mesh);
                    blocks.push(mesh);
                }
                // Mineração de bloco
                window.addEventListener('mousedown', (e) => {
                    if (isInventoryOpen || !controls.isLocked) return;
                    // Raycast para blocos
                    const raycaster = new THREE.Raycaster();
                    raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
                    const intersects = raycaster.intersectObjects(blocks);
                    if (intersects.length > 0) {
                        const block = intersects[0].object;
                        addToInventory(block.userData.type);
                        scene.remove(block);
                        const idx = blocks.indexOf(block);
                        if (idx >= 0) blocks.splice(idx,1);
                        return;
                    }
                });
                // --- CRAFTING SIMPLES ---
                // Interface
                const craftingRecipes = [
                    { name: 'Espada', requires: { stone: 2, wood: 1 }, result: { type: 'sword', name: 'Espada' } },
                    { name: 'Comida', requires: { dirt: 1 }, result: { type: 'food', name: 'Maçã' } }
                ];
                function openCrafting() {
                    let html = '<h2>Crafting</h2>';
                    craftingRecipes.forEach((r, i) => {
                        html += `<div style="margin:8px 0;"><b>${r.name}</b> <button onclick="craftItem(${i})">Craft</button><br><small>Requer: `;
                        html += Object.entries(r.requires).map(([k,v])=>`${v} ${k}`).join(', ');
                        html += '</small></div>';
                    });
                    const div = document.createElement('div');
                    div.id = 'crafting-modal';
                    div.style = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#222;color:#fff;padding:30px;z-index:200;border-radius:10px;box-shadow:0 0 20px #000b;';
                    div.innerHTML = html + '<br><button onclick="closeCrafting()">Fechar</button>';
                    document.body.appendChild(div);
                }
                window.openCrafting = openCrafting;
                window.closeCrafting = function() {
                    const m = document.getElementById('crafting-modal');
                    if (m) m.remove();
                };
                window.craftItem = function(idx) {
                    const recipe = craftingRecipes[idx];
                    // Checa se tem os itens
                    const counts = {};
                    inventory.forEach(i=>{counts[i.type]=(counts[i.type]||0)+1;});
                    let can = true;
                    for (let k in recipe.requires) {
                        if (!counts[k] || counts[k]<recipe.requires[k]) can = false;
                    }
                    if (!can) { alert('Faltam ingredientes!'); return; }
                    // Remove ingredientes
                    for (let k in recipe.requires) {
                        let needed = recipe.requires[k];
                        for (let i=inventory.length-1;i>=0&&needed>0;i--) {
                            if (inventory[i].type===k) { inventory.splice(i,1); needed--; }
                        }
                    }
                    // Adiciona resultado
                    inventory.push({ type: recipe.result.type, name: recipe.result.name, id: Date.now()+Math.random() });
                    renderInventory();
                    alert('Item criado!');
                };
        // Exibe a espada na mão do jogador (câmera)
        function showSwordInHand() {
            if (swordMesh) return;
            // Lâmina
            const bladeGeo = new THREE.BoxGeometry(0.12, 0.8, 0.12);
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xcccccc });
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            blade.position.y = 0.32;
            // Cabo
            const handleGeo = new THREE.CylinderGeometry(0.07, 0.07, 0.28, 8);
            const handleMat = new THREE.MeshStandardMaterial({ color: 0x8B5A2B });
            const handle = new THREE.Mesh(handleGeo, handleMat);
            handle.position.y = -0.28;
            // Guarda
            const guardGeo = new THREE.BoxGeometry(0.22, 0.06, 0.22);
            const guardMat = new THREE.MeshStandardMaterial({ color: 0xFFD700 });
            const guard = new THREE.Mesh(guardGeo, guardMat);
            guard.position.y = 0.01;
            // Agrupar
            swordMesh = new THREE.Group();
            swordMesh.add(blade);
            swordMesh.add(handle);
            swordMesh.add(guard);
            // Posição e rotação para "mão direita" do jogador
            swordMesh.position.set(0.38, -0.45, -0.7);
            swordMesh.rotation.x = Math.PI / 7;
            swordMesh.rotation.y = Math.PI / 8;
            swordMesh.rotation.z = Math.PI / 2.1;
            camera.add(swordMesh);
        }

        function hideSwordInHand() {
            if (swordMesh) {
                camera.remove(swordMesh);
                swordMesh = null;
            }
        }
        }

        // --- LÓGICA DE JOGO ---

        function checkInteraction() {
            if (isInventoryOpen) return; // Não pega itens se inv estiver aberto

            const playerPos = controls.getObject().position;
            let found = false;

            for (let i = 0; i < itemsInWorld.length; i++) {
                const item = itemsInWorld[i];
                if (!item.userData.active) continue;

                if (playerPos.distanceTo(item.position) < 4) {
                    addToInventory(item.userData.type);
                    
                    // Remove da cena
                    item.visible = false; // Apenas esconde para performance
                    item.userData.active = false; 
                    found = true;
                    break; 
                }
            }
        }

        function updateHUD() {
            document.getElementById('health-bar').style.width = health + '%';
            document.getElementById('hunger-bar').style.width = hunger + '%';
            document.getElementById('thirst-bar').style.width = thirst + '%';
            const sBar = document.getElementById('stamina-bar');
            if (sBar) sBar.style.width = Math.max(0, Math.min(100, stamina)) + '%';
        }

        // Variáveis de Física
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let canJump = false;

        function animate() {
            requestAnimationFrame(animate);
                        // Atualizar barras de vida dos inimigos
                        const barsContainer = document.getElementById('enemies-health-bars');
                        enemies.forEach(enemy => {
                            if (!enemy.userData.healthBarId) return;
                            // Projeta posição 3D para 2D
                            const pos = enemy.position.clone();
                            pos.y += 2.2; // Acima da cabeça
                            pos.project(camera);
                            const x = (pos.x * 0.5 + 0.5) * window.innerWidth;
                            const y = (-pos.y * 0.5 + 0.5) * window.innerHeight;
                            const bar = enemy.userData.healthBarId;
                            // centralizamos o elemento usando translate(-50%, -110%), então posicionamos no ponto projetado
                            bar.style.left = x + 'px';
                            bar.style.top = (y - 12) + 'px';
                                // Atualiza vida e visibilidade somente se estiver perto do jogador
                                const inner = bar.querySelector('.enemy-health-inner');
                                const percent = Math.max(0, enemy.userData.health / enemy.userData.maxHealth);
                                if (inner) inner.style.width = (percent * 100) + '%';
                                const playerPos = controls.getObject().position;
                                const ENEMY_BAR_SHOW_DISTANCE = 20; // ajustar conforme desejado
                                const distToPlayer = enemy.position.distanceTo(playerPos);
                                // Verifica se o jogador está olhando para o inimigo
                                const forward = new THREE.Vector3();
                                camera.getWorldDirection(forward);
                                // Ignora componente Y para considerar apenas direção horizontal (XZ)
                                forward.y = 0;
                                if (forward.lengthSq() > 0) forward.normalize();
                                const toEnemy = enemy.position.clone().sub(playerPos);
                                toEnemy.y = 0;
                                let facing = false;
                                if (toEnemy.lengthSq() > 0) {
                                    toEnemy.normalize();
                                    const DOT_THRESHOLD = 0.7; // ~45 graus de tolerância
                                    facing = forward.dot(toEnemy) > DOT_THRESHOLD;
                                }
                                bar.style.display = (enemy.userData.alive && percent > 0 && distToPlayer < ENEMY_BAR_SHOW_DISTANCE && facing) ? 'block' : 'none';
                        });

            const time = performance.now();
            const delta = (time - lastTime) / 1000;
            lastTime = time;

            updateDayNight(delta);
            // Detect day/night cycle wrap (completed a full cycle) and decrement slow-decay timer
            if (previousTimeOfDay > timeOfDay) {
                if (slowDecayActive) {
                    slowDecayCyclesLeft -= 1;
                    if (slowDecayCyclesLeft <= 0) {
                        slowDecayActive = false;
                    }
                }
            }
            previousTimeOfDay = timeOfDay;

            // Só processa lógica se não estiver pausado e não estiver no inventário
            // Mas hunger/thirst continuam caindo? Em jogos survival, geralmente sim.
            // Aqui vamos pausar o movimento, mas manter o status caindo.
            
            if (!isInventoryOpen && controls.isLocked) {
                // Diminuição de status (aplica multiplicador se slowDecay estiver ativo)
                const decayMultiplier = slowDecayActive ? SLOW_DECAY_FACTOR : 1.0;
                hunger -= 1.0 * decayMultiplier * delta;
                thirst -= 1.5 * decayMultiplier * delta;

                if (hunger <= 0 || thirst <= 0) health -= 3 * delta;
                if (health <= 0) {
                    health = 0;
                    controls.unlock();
                    alert("Você morreu de fome/sede!");
                    location.reload();
                }
                updateHUD();

                // Movimento
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= 9.8 * 10.0 * delta; // Gravidade

                direction.z = Number(!!keyState['KeyW'] || !!keyState['ArrowUp']) - Number(!!keyState['KeyS'] || !!keyState['ArrowDown']);
                direction.x = Number(!!keyState['KeyD'] || !!keyState['ArrowRight']) - Number(!!keyState['KeyA'] || !!keyState['ArrowLeft']);
                direction.normalize();

                // Movimentação: walking vs sprint
                const moving = (keyState['KeyW'] || keyState['KeyS'] || keyState['ArrowUp'] || keyState['ArrowDown'] || keyState['KeyA'] || keyState['KeyD'] || keyState['ArrowLeft'] || keyState['ArrowRight']);
                const wantSprint = (keyState['ShiftLeft'] || keyState['ShiftRight']);

                // Decide se está correndo: tem stamina e está tentando sprintar e movendo
                isSprinting = wantSprint && stamina > 0 && moving;

                let currentSpeed = WALK_SPEED;
                if (isSprinting) currentSpeed = SPRINT_SPEED;
                else if (stamina <= 0) currentSpeed = WALK_SPEED_EXHAUSTED;

                if (keyState['KeyW'] || keyState['KeyS'] || keyState['ArrowUp'] || keyState['ArrowDown']) 
                    velocity.z -= direction.z * currentSpeed * delta;
                if (keyState['KeyD'] || keyState['KeyA'] || keyState['ArrowRight'] || keyState['ArrowLeft']) 
                    velocity.x -= direction.x * currentSpeed * delta;

                // Stamina drain / regen
                if (isSprinting) {
                    stamina -= STAMINA_DRAIN * delta;
                    if (stamina < 0) stamina = 0;
                } else {
                    // Regenerates over time when not sprinting
                    stamina += STAMINA_REGEN * delta;
                    if (stamina > MAX_STAMINA) stamina = MAX_STAMINA;
                }
                // Atualiza HUD para refletir stamina atual
                updateHUD();

                // Pulo
                if (keyState['Space'] && canJump) {
                    velocity.y += 25;
                    canJump = false;
                }

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                controls.getObject().position.y += (velocity.y * delta);

                // Colisão Terreno
                const pos = controls.getObject().position;
                
                // Limites do mapa
                if (pos.x < -WORLD_WIDTH/2) pos.x = -WORLD_WIDTH/2;
                if (pos.x > WORLD_WIDTH/2) pos.x = WORLD_WIDTH/2;
                if (pos.z < -WORLD_DEPTH/2) pos.z = -WORLD_DEPTH/2;
                if (pos.z > WORLD_DEPTH/2) pos.z = WORLD_DEPTH/2;

                const terrainH = getNoiseHeight(pos.x, pos.z);
                if (pos.y < terrainH + PLAYER_HEIGHT) {
                    velocity.y = 0;
                    pos.y = terrainH + PLAYER_HEIGHT;
                    canJump = true;
                }
            }

            // Animação dos itens (girar) — usa baseY para evitar acúmulo vertical
            itemsInWorld.forEach(item => {
                if (item.userData.active) {
                    item.rotation.y += delta;
                    const bob = Math.sin(time * 0.003 + (item.userData.phase || 0)) * 0.25; // amplitude em unidades
                    item.position.y = (item.userData.baseY !== undefined ? item.userData.baseY : item.position.y) + bob;
                }
            });

            // INIMIGOS: movimentação simples e dano
            if (!isInventoryOpen && controls.isLocked) {
                const playerPos = controls.getObject().position;
                enemies.forEach(enemy => {
                    if (!enemy.userData.alive) return;
                    // Movimento simples: segue o jogador se perto
                    const dist = enemy.position.distanceTo(playerPos);
                    if (dist < 30 && dist > 2.5) {
                        const dir = new THREE.Vector3().subVectors(playerPos, enemy.position).normalize();
                        const spd = (enemy.userData && enemy.userData.speed) ? enemy.userData.speed : 3.5;
                        enemy.position.x += dir.x * delta * spd;
                        enemy.position.z += dir.z * delta * spd;
                        // Ajusta altura ao terreno
                        const terrainY = getNoiseHeight(enemy.position.x, enemy.position.z);
                        // vertical offset depends on enemy height; keep roughly grounded
                        enemy.position.y = terrainY + (enemy.userData && enemy.userData.kind === 'zombie' ? 1.2 : 1);
                    }
                    // Dano ao jogador
                    if (dist < 2.2) {
                        health -= enemy.userData.damage * delta;
                        updateHUD();
                    }
                });
            }
            
            // Check mensagem 'E'
            if (!isInventoryOpen && controls.isLocked) {
                const msg = document.getElementById('interaction-msg');
                const pos = controls.getObject().position;
                let near = false;
                for(let item of itemsInWorld) {
                    if(item.userData.active && item.position.distanceTo(pos) < 4) {
                        near = true; break;
                    }
                }
                // Só altera se não estiver mostrando a mensagem de "Pegou Item"
                if (!msg.innerText.includes('Pegou')) {
                    msg.style.display = near ? 'block' : 'none';
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // animate(); -- iniciará somente quando o jogador clicar em 'Começar'

        // Tecla C para abrir crafting
        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyC' && controls.isLocked) openCrafting();
        });

        // Ataque com espada (deve estar dentro do script)
        window.addEventListener('mousedown', (e) => {
            if (!equippedSword || isInventoryOpen || !controls.isLocked) return;
            // Ataque: verifica inimigos próximos à frente
            const playerPos = controls.getObject().position.clone();
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);
            let hit = false;
            enemies.forEach(enemy => {
                if (!enemy.userData.alive || enemy.userData.health <= 0) return;
                const toEnemy = enemy.position.clone().sub(playerPos);
                const dist = toEnemy.length();
                // Ângulo entre frente e inimigo
                const angle = forward.angleTo(toEnemy.normalize());
                if (dist < 3.2 && angle < Math.PI / 4) {
                    // Dano
                    enemy.userData.health -= 40;
                    if (enemy.userData.health <= 0) {
                        enemy.userData.alive = false;
                        enemy.visible = false;
                    }
                    hit = true;
                }
            });
            if (hit) {
                // Animação simples de "ataque"
                if (swordMesh) {
                    swordMesh.rotation.x -= 0.7;
                    setTimeout(() => { if (swordMesh) swordMesh.rotation.x += 0.7; }, 120);
                }
            }
        });

    </script>
</body>
</html>
